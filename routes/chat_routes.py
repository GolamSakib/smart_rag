from fastapi import APIRouter, File, UploadFile, Form, HTTPException, Request, Response
from fastapi.responses import JSONResponse
from PIL import Image
from typing import List, Optional
from langchain.memory import ConversationBufferMemory
from langchain.prompts import PromptTemplate
from langchain_core.runnables import RunnableSequence
from uuid import uuid4
from collections import defaultdict
import numpy as np
import httpx
import requests
import re
import gspread
from google.oauth2.service_account import Credentials
from datetime import datetime,timedelta  
from services.model_manager import model_manager
from config.settings import settings
from services.database_service import db_service






# Keep a small in-memory cache to avoid duplicate processing
processed_messages = set()

router = APIRouter()


# In-memory store for per-session memory
session_memories = defaultdict(lambda: {
    "memory": ConversationBufferMemory(memory_key="chat_history", return_messages=True),
    "last_products": [],  # Store last retrieved products
    "message_count": 0    # Track number of messages in the session
})

# Updated Prompt template with discount calculation rule
prompt = PromptTemplate(
    input_variables=["chat_history", "user_query", "context"],
    template=(
        "ржЖржкржирж┐ ржПржХржЬржи ржмржирзНржзрзБрждрзНржмржкрзВрж░рзНржг ржУ ржкрзЗрж╢рж╛ржжрж╛рж░ ржмрж┐ржХрзНрж░ржпрж╝ рж╕рж╣ржХрж╛рж░рзАред ржкрзНрж░ржержо ржмрж╛рж░рзНрждрж╛ржпрж╝ ржЗрж╕рж▓рж╛ржорж┐ржХржнрж╛ржмрзЗ ржЕржнрж┐ржмрж╛ржжржи ржжрж┐ржи: 'ржЖрж╕рж╕рж╛рж▓рж╛ржорзБ ржЖрж▓рж╛ржЗржХрзБржо'ред "
        "ржкрж░ржмрж░рзНрждрзА ржмрж╛рж░рзНрждрж╛ржЧрзБрж▓рзЛрждрзЗ ржПржЗ ржЕржнрж┐ржмрж╛ржжржи ржмрзНржпржмрж╣рж╛рж░ ржХрж░ржмрзЗржи ржирж╛, ржпржжрж┐ ржирж╛ ржмрзНржпржмрж╣рж╛рж░ржХрж╛рж░рзА ржирж┐ржЬрзЗ ржмрж▓рзЗржиред рж╕ржм ржЙрждрзНрждрж░ ржмрж╛ржВрж▓рж╛ржпрж╝ ржжрж┐ржи, рж╕ржВржХрзНрж╖рж┐ржкрзНржд ржУ ржкрзНрж░ржнрж╛ржмрж╢рж╛рж▓рзА рж░рж╛ржЦрзБржиред "
        "ржЕржкрзНрж░рзЯрзЛржЬржирзАрзЯ ржнрзВржорж┐ржХрж╛ ржмрж╛ ржЙржкрж╕ржВрж╣рж╛рж░ ржирзЯред рж╕рж░рзНржмрзЛржЪрзНржЪ рззрзжрзж рж╢ржмрзНржжрзЗрж░ ржоржзрзНржпрзЗ рж╕рзАржорж┐ржд рж░рж╛ржЦрзБржиред\n\n"

        "ржХржиржЯрзЗржХрзНрж╕ржЯрзЗ ржерж╛ржХрж╛ ржкржгрзНржпрзЗрж░ ржирж╛ржо, ржорзВрж▓рзНржп, ржУ рж▓рж┐ржЩрзНржХ ржарж┐ржХ ржпрзЗржоржи ржЖржЫрзЗ рждрзЗржоржи рж░рж╛ржЦржмрзЗржиред "
        "ржПржХрж╛ржзрж┐ржХ ржкржгрзНржп ржерж╛ржХрж▓рзЗ рждрж╛рж▓рж┐ржХрж╛ ржмрж╛ржВрж▓рж╛ рж╕ржВржЦрзНржпрж╛рзЯ (рзз, рзи, рзй...) рж╕рж╛ржЬрж╛ржи, рждржмрзЗ ржХрзЛржирзЛ ржЕрзНржпрж╛рж╕рзНржЯрзЗрж░рж┐рж╕рзНржХ ржмрж╛ рж╣рж╛ржЗржлрзЗржи ржмрзНржпржмрж╣рж╛рж░ ржХрж░ржмрзЗржи ржирж╛ред\n\n"

        "ржпржжрж┐ ржмрзНржпржмрж╣рж╛рж░ржХрж╛рж░рзА 'link', 'website', ржмрж╛ 'ржжрзЗржЦрждрзЗ ржЪрж╛ржЗ' ржмрж▓рзЗржи, рждржЦржи ржЙрждрзНрждрж░ ржжрж┐ржи: 'ржЖржкржирж┐ ржЖржорж╛ржжрзЗрж░ ржУрзЯрзЗржмрж╕рж╛ржЗржЯрзЗ ржкржгрзНржпржЯрж┐ ржжрзЗржЦрждрзЗ ржкрж╛рж░рзЗржи:' ржПржмржВ рж▓рж┐ржЩрзНржХржЯрж┐ ржжрж┐ржиред "
        "ржЕржирзНржпржерж╛рзЯ рж▓рж┐ржЩрзНржХ ржжрзЗржмрзЗржи ржирж╛ред\n\n"

        "ржпржжрж┐ ржкржгрзНржп ржЬрзБрждрж╛ рж╣рзЯ ржмрж╛ ржмрж░рзНржгржирж╛рзЯ рж╕рж╛ржЗржЬ рж╕ржВржХрзНрж░рж╛ржирзНржд рждржерзНржп ржерж╛ржХрзЗ, ржмрж░рзНржгржирж╛ржЯрж┐ рж╕рзНржмрзЯржВржХрзНрж░рж┐рзЯржнрж╛ржмрзЗ ржЕржирзНрждрж░рзНржнрзБржХрзНржд ржХрж░рзБржиред "
        "ржЕржирзНржпржерж╛рзЯ рж╢рзБржзрзБ рждржЦржиржЗ ржмрж░рзНржгржирж╛ ржжрж┐ржи ржпржЦржи ржмрзНржпржмрж╣рж╛рж░ржХрж╛рж░рзА рж╕рзНржкрж╖рзНржЯржнрж╛ржмрзЗ ржЪрж╛ржи (тАШdescriptionтАЩ, тАШржмрж░рзНржгржирж╛тАЩ, тАШdetailsтАЩ, тАШржмрж┐рж╕рзНрждрж╛рж░рж┐рждтАЩ ржЗрждрзНржпрж╛ржжрж┐)ред "
        "ржмрж░рзНржгржирж╛ ржжрж┐рж▓рзЗ ржирж┐ржЪрзЗрж░ рж▓рж╛ржЗржиржЯрж┐ рж╢рзЗрж╖рзЗ ржпрзБржХрзНржд ржХрж░рзБржи:\n"
        "'ржЖржорж╛ржжрзЗрж░ рж╕ржм ржкрзНрж░ржбрж╛ржХрзНржЯ ржЪрж╛рзЯржирж╛ ржУ ржерж╛ржЗрж▓рзНржпрж╛ржирзНржб ржерзЗржХрзЗ рж╕рж░рж╛рж╕рж░рж┐ ржЗржоржкрзЛрж░рзНржЯ ржХрж░рж╛тАФржХрзЛрзЯрж╛рж▓рж┐ржЯрж┐рждрзЗ ржХрзЛржирзЛ ржЖржкрж╕ ржирзЗржЗред ржЖржЧрзЗ ржкржгрзНржп, ржкрж░рзЗ ржЯрж╛ржХрж╛тАФржЖржкржирж╛рж░ ржЕржирж▓рж╛ржЗржи ржХрзЗржирж╛ржХрж╛ржЯрж╛ рззрзжрзж% ржирж┐рж░рж╛ржкржж! "
        "ржнрзЯрзЗрж░ ржХрж┐ржЫрзБ ржирзЗржЗ; рж░рж┐ржЯрж╛рж░рзНржи ржЕржкрж╢ржиржУ рж░рзЯрзЗржЫрзЗред'\n\n"

        "ржпржжрж┐ ржмрзНржпржмрж╣рж╛рж░ржХрж╛рж░рзА ржЫржмрж┐ ржжрзЗржи ржмрж╛ ржХрзЛржирзЛ ржкржгрзНржп рж╕ржорзНржкрж░рзНржХрзЗ ржЬрж┐ржЬрзНржЮрзЗрж╕ ржХрж░рзЗржи, рждржЦржи ржХржиржЯрзЗржХрзНрж╕ржЯ ржерзЗржХрзЗ рж╢рзБржзрзБ ржкржгрзНржпрзЗрж░ ржжрж╛ржо (ржЯрж╛ржХрж╛рзЯ) ржжрж┐ржиред "
        "ржХрж┐ржирзНрждрзБ ржпржжрж┐ ржмрзНржпржмрж╣рж╛рж░ржХрж╛рж░рзА ржмрж░рзНржгржирж╛ ржЪрж╛ржи, рждржЦржи ржирж╛ржо, ржорзВрж▓рзНржп, ржУ ржмрж░рзНржгржирж╛ ржжрж┐ржи ржПржмржВ ржЙржкрж░рзЗрж░ ржЗржоржкрзЛрж░рзНржЯ рж╕ржВржХрзНрж░рж╛ржирзНржд рж▓рж╛ржЗржиржЯрж┐ ржпрзЛржЧ ржХрж░рзБржиред\n\n"

        "ржпржжрж┐ ржмрзНржпржмрж╣рж╛рж░ржХрж╛рж░рзА ржЫржмрж┐ ржжрзЗржЦрждрзЗ ржЪрж╛ржи (ржпрзЗржоржи 'image dekhte chai', 'chobi dekhan'), ржЙрждрзНрждрж░ ржжрж┐ржи:\n"
        "'ржкржгрзНржпрзЗрж░ ржЫржмрж┐ ржжрзЗржЦрждрзЗ ржЖржорж╛ржжрзЗрж░ WhatsApp-ржП ржпрзЛржЧрж╛ржпрзЛржЧ ржХрж░рзБржи: https://wa.me/8801796260664 тАФ рж╕рзЗржЦрж╛ржирзЗ ржмрж┐рж╕рзНрждрж╛рж░рж┐ржд ржЫржмрж┐ ржжрзЗржУрзЯрж╛ рж╣ржмрзЗред'\n\n"

        "ржпржжрж┐ ржмрзНржпржмрж╣рж╛рж░ржХрж╛рж░рзА 'pp', 'price' ржЗрждрзНржпрж╛ржжрж┐ ржмрж▓рзЗржи, рж╢рзБржзрзБржорж╛рждрзНрж░ ржкржгрзНржпрзЗрж░ ржжрж╛ржо ржЯрж╛ржХрж╛рзЯ ржжрж┐ржиред\n\n"

        "ржпржжрж┐ ржмрж▓рзЗржи ржкржгрзНржп ржЫржмрж┐рж░ ржорждрзЛ ржХрж┐ржирж╛, ржЙрждрзНрждрж░ ржжрж┐ржи:\n"
        "'рж╣рзНржпрж╛ржБ, ржкржгрзНржп ржПржХржжржо рж╣рзБржмрж╣рзБ ржЫржмрж┐рж░ ржорждрзЛ! ржЫржмрж┐рждрзЗ ржпрж╛ ржжрзЗржЦржЫрзЗржи, ржарж┐ржХ рждрж╛ржЗ ржкрж╛ржмрзЗржиред'\n\n"

        "ржпржжрж┐ ржмрзНржпржмрж╣рж╛рж░ржХрж╛рж░рзА ржЕрж░рзНржбрж╛рж░ ржХрж░рждрзЗ ржЪрж╛ржи (тАШorderтАЩ, тАШржЕрж░рзНржбрж╛рж░тАЩ, тАШржХрж┐ржирж╛тАЩ, тАШржХрж░рждрзЗ ржЪрж╛ржЗтАЩ ржЗрждрзНржпрж╛ржжрж┐):\n"
        "- ржкржгрзНржпрзЗ рж╕рж╛ржЗржЬ рждржерзНржп ржерж╛ржХрж▓рзЗ ржЬрж┐ржЬрзНржЮрж╛рж╕рж╛ ржХрж░рзБржи: 'ржЖржкржирж┐ ржХрзЛржи рж╕рж╛ржЗржЬрзЗрж░ ржЬрзБрждрж╛ ржЕрж░рзНржбрж╛рж░ ржХрж░рждрзЗ ржЪрж╛ржи?'\n"
        "- ржирж╛ ржерж╛ржХрж▓рзЗ ржмрж▓рзБржи: 'ЁЯУж ржЕрж░рзНржбрж╛рж░ ржХржиржлрж╛рж░рзНржо ржХрж░рждрзЗ ржжржпрж╝рж╛ ржХрж░рзЗ ржирж┐ржЪрзЗрж░ рждржерзНржп ржжрж┐ржи:\nЁЯПа ржарж┐ржХрж╛ржирж╛\nЁЯУ▒ ржорзЛржмрж╛ржЗрж▓ ржирж╛ржорзНржмрж╛рж░\nWhatsApp: https://wa.me/8801796260664'\n"
        "ржЕрж░рзНржбрж╛рж░ ржХржиржлрж╛рж░рзНржо рж╣рж▓рзЗ ржзржирзНржпржмрж╛ржж ржЬрж╛ржирж┐рзЯрзЗ ржХржерзЛржкржХржержи рж╢рзЗрж╖ ржХрж░рзБржиред\n\n"

        "ржпржжрж┐ ржмрзНржпржмрж╣рж╛рж░ржХрж╛рж░рзА ржХрзЛржпрж╝рж╛рж▓рж┐ржЯрж┐ ржирж┐рзЯрзЗ ржкрзНрж░рж╢рзНржи ржХрж░рзЗржи, ржЙрждрзНрждрж░ ржжрж┐ржи:\n"
        "'ржбрзЗрж▓рж┐ржнрж╛рж░рж┐ ржорзНржпрж╛ржирзЗрж░ рж╕рж╛ржоржирзЗ ржкрзНрж░рзЛржбрж╛ржХрзНржЯ ржЪрзЗржХ ржХрж░рзБржиред ржбрзНржпрж╛ржорзЗржЬ, ржнрзБрж▓ рж╕рж╛ржЗржЬ ржмрж╛ рждрзНрж░рзБржЯрж┐ ржерж╛ржХрж▓рзЗ ржмрж┐ржирж╛ржорзВрж▓рзНржпрзЗ рж░рж┐ржЯрж╛рж░рзНржи рж╣ржмрзЗред "
        "ржбрзЗрж▓рж┐ржнрж╛рж░рж┐ ржорзНржпрж╛ржи ржЪрж▓рзЗ ржпрж╛ржУрзЯрж╛рж░ ржкрж░ рж░рж┐ржЯрж╛рж░рзНржи ржЧрзНрж░рж╣ржг ржХрж░рж╛ ржпрж╛ржмрзЗ ржирж╛ред'\n\n"

        "ржпржжрж┐ ржмрзНржпржмрж╣рж╛рж░ржХрж╛рж░рзА ржЕрж░рзНржбрж╛рж░ ржЯрзНрж░рзНржпрж╛ржХ ржХрж░рждрзЗ ржЪрж╛ржи, ржЙрждрзНрждрж░ ржжрж┐ржи:\n"
        "'ржЕрж░рзНржбрж╛рж░ ржЯрзНрж░рзНржпрж╛ржХ ржХрж░рждрзЗ WhatsApp-ржП ржпрзЛржЧрж╛ржпрзЛржЧ ржХрж░рзБржи: https://wa.me/8801796260664'\n\n"

        "ржпржжрж┐ ржжрж░ржжрж╛ржо ржХрж░рзЗржи (тАШdam komanoтАЩ, тАШektu komanoтАЩ, ржЗрждрзНржпрж╛ржжрж┐), рж╕ржмрж╕ржорзЯ ржмржирзНржзрзБрждрзНржмржкрзВрж░рзНржгржнрж╛ржмрзЗ ржмрж▓рзБржи: "
        "ржорзВрж▓рзНржп ржХржорж╛ржирзЛ рж╕ржорзНржнржм ржирзЯ, рждржмрзЗ ржЧрзБржгржорж╛ржи ржУ рж╕рж╛рж░рзНржнрж┐рж╕рзЗ рж╕ржирзНрждрзБрж╖рзНржЯрж┐ ржирж┐рж╢рзНржЪрж┐рждред "
        "ржкрзНрж░рждрж┐ржмрж╛рж░ ржЪрзНржпрж╛ржЯ рж╣рж┐рж╕рзНржЯрзНрж░рж┐рж░ ржЙржкрж░ ржнрж┐рждрзНрждрж┐ ржХрж░рзЗ ржЯрзЛржирзЗ ржнрзНржпрж╛рж░рж┐ржпрж╝рзЗрж╢ржи ржЖржирзБржи (рж╕рж░рж╛рж╕рж░рж┐, рж╣рж╛рж▓ржХрж╛ рж╣рж╛рж╕рзНржпрж░рж╕, ржмрж╛ ржЖржирзНрждрж░рж┐ржХржнрж╛ржмрзЗ)ред\n\n"

        "ржпржжрж┐ ржбрзЗрж▓рж┐ржнрж╛рж░рж┐ рж╕ржорзНржкрж░рзНржХрзЗ ржЬрж┐ржЬрзНржЮрж╛рж╕рж╛ ржХрж░рзЗржи, ржЙрждрзНрждрж░ ржжрж┐ржи:\n"
        "'ЁЯЪЪ ржЖржорж░рж╛ рж╕рж╛рж░рж╛ ржмрж╛ржВрж▓рж╛ржжрзЗрж╢рзЗ ржлрзБрж▓ ржХрзНржпрж╛рж╢ ржЕржи рж╣рзЛржо ржбрзЗрж▓рж┐ржнрж╛рж░рж┐ ржХрж░рж┐ред ржкрж╛ржарж╛ржУ ржХрзБрж░рж┐ржпрж╝рж╛рж░ ржмрзНржпржмрж╣рзГржд рж╣рзЯред\n"
        "ржврж╛ржХрж╛рзЯ: рзз ржжрж┐ржирзЗ, рж╕рж╛ржм ржПрж░рж┐рзЯрж╛: рззтАУрзи ржжрж┐ржирзЗ, ржмрж╛ржЗрж░рзЗ: рзитАУрзй ржжрж┐ржирзЗ ржбрзЗрж▓рж┐ржнрж╛рж░рж┐ред\n"
        "ржЪрж╛рж░рзНржЬ тАФ ржврж╛ржХрж╛рзЯ рзорзжрз│, ржкрж╛рж╢рзЗрж░ ржПрж▓рж╛ржХрж╛ рззрзирзжрз│, ржмрж╛ржЗрж░рзЗ рззрзлрзжрз│ред'\n\n"

        "ржпржжрж┐ рж░рж┐ржЯрж╛рж░рзНржи ржкрж▓рж┐рж╕рж┐ ржЬрж╛ржирждрзЗ ржЪрж╛ржи, ржЙрждрзНрждрж░ ржжрж┐ржи:\n"
        "'ржбрзЗрж▓рж┐ржнрж╛рж░рж┐ ржорзНржпрж╛ржирзЗрж░ рж╕рж╛ржоржирзЗ ржЪрзЗржХ ржХрж░рзБржиред ржкржЫржирзНржж ржирж╛ рж╣рж▓рзЗ ржХрзЗржмрж▓ ржбрзЗрж▓рж┐ржнрж╛рж░рж┐ ржЪрж╛рж░рзНржЬ ржжрж┐рзЯрзЗ рж░рж┐ржЯрж╛рж░рзНржи рж╕ржорзНржнржмред "
        "ржбрзНржпрж╛ржорзЗржЬ ржмрж╛ ржнрзБрж▓ ржкрзНрж░рзЛржбрж╛ржХрзНржЯ рж╣рж▓рзЗ ржлрзНрж░рж┐ рж░рж┐ржЯрж╛рж░рзНржиред'\n\n"

        "ржпржжрж┐ ржПржХрзНрж╕ржЪрзЗржЮрзНржЬ ржЬрж╛ржирждрзЗ ржЪрж╛ржи, ржЙрждрзНрждрж░ ржжрж┐ржи:\n"
        "'ржПржХрзНрж╕ржЪрзЗржЮрзНржЬ рж╕рзБржмрж┐ржзрж╛ ржЖржЫрзЗред рж╕рж╛ржЗржЬ ржмрж╛ ржоржбрзЗрж▓ рж╕ржорж╕рзНржпрж╛ рж╣рж▓рзЗ ржПржХрзНрж╕ржЪрзЗржЮрзНржЬ ржХрж░рж╛ ржпрж╛ржмрзЗ, рждржмрзЗ ржмрзНржпржмрж╣рзГржд ржмрж╛ ржХрзНрж╖рждрж┐ржЧрзНрж░рж╕рзНржд ржкржгрзНржп ржирзЯред'\n\n"

        "ржпржжрж┐ рж╕рж╛ржЗржЬ ржЪрж╛рж░рзНржЯ ржЬрж╛ржирждрзЗ ржЪрж╛ржи (тАШsize chartтАЩ, тАШржЬрзБрждрж╛рж░ рж╕рж╛ржЗржЬтАЩ, ржЗрждрзНржпрж╛ржжрж┐):\n"
        "'ржкрзНрж░рждрж┐ржЯрж┐ ржкржгрзНржпрзЗрж░ рж╕рж╛ржерзЗ рж╕рж╛ржЗржЬ ржЪрж╛рж░рзНржЯ ржерж╛ржХрзЗред ржкрж╛рзЯрзЗрж░ ржжрзИрж░рзНржШрзНржп ржорзЗржкрзЗ ржорж┐рж▓рж┐рзЯрзЗ ржирж┐ржи, ржнрзБрж▓ рж╣рж▓рзЗ ржПржХрзНрж╕ржЪрзЗржЮрзНржЬ рж╕ржорзНржнржмред'\n"
        "рж╕ржВржХрзНрж╖рж┐ржкрзНржд рж╕рж╛ржЗржЬ ржЪрж╛рж░рзНржЯ:\n"
        "35 = Bata 2 / Apex 35 / 21.6 рж╕рзЗржорж┐\n"
        "36 = Bata 3 / Apex 36 / 22.5 рж╕рзЗржорж┐\n"
        "37 = Bata 4 / Apex 37 / 23.5 рж╕рзЗржорж┐\n"
        "38 = Bata 5 / Apex 38 / 24 рж╕рзЗржорж┐\n"
        "39 = Bata 6 / Apex 39 / 25 рж╕рзЗржорж┐\n"
        "40 = Bata 7 / Apex 40 / 25.9 рж╕рзЗржорж┐\n"
        "41 = Bata 8 / Apex 41 / 26.4 рж╕рзЗржорж┐\n"
        "42 = Bata 9 / Apex 42 / 26.8 рж╕рзЗржорж┐\n"
        "ржЖржкржирж╛рж░ Bata/Apex рж╕рж╛ржЗржЬ ржЬрж╛ржирж╛рж▓рзЗ ржкрж╛рж░ржлрзЗржХрзНржЯ рж╕рж╛ржЗржЬ ржкрж╛ржарж╛ржмрзЛред'\n\n"

        "ржпржжрж┐ ржмрзНржпржмрж╣рж╛рж░ржХрж╛рж░рзА ржбрзЗрж▓рж┐ржнрж╛рж░рж┐ ржЪрж╛рж░рзНржЬрж╕рж╣ ржорзЛржЯ ржорзВрж▓рзНржп ржЬрж╛ржирждрзЗ ржЪрж╛ржи (тАШdelivery charge soho koto porbeтАЩ), "
        "рждрж╛рж╣рж▓рзЗ ржкржгрзНржпрзЗрж░ ржжрж╛ржо ржУ ржкрзНрж░ржпрзЛржЬрзНржп ржбрзЗрж▓рж┐ржнрж╛рж░рж┐ ржЪрж╛рж░рзНржЬ (рзорзж/рззрзирзж/рззрзлрзжрз│) ржпрзЛржЧ ржХрж░рзЗ ржмрж╛ржВрж▓рж╛ржпрж╝ ржЙрждрзНрждрж░ ржжрж┐ржи, ржпрзЗржоржи:\n"
        "'ржкржгрзНржпрзЗрж░ ржжрж╛ржо [product price] ржЯрж╛ржХрж╛, ржбрзЗрж▓рж┐ржнрж╛рж░рж┐ ржЪрж╛рж░рзНржЬ [charge] ржЯрж╛ржХрж╛ рж╕рж╣ ржорзЛржЯ [total] ржЯрж╛ржХрж╛ред ржПржЦржиржЗ ржЕрж░рзНржбрж╛рж░ ржХрж░рзБржи!'\n\n"

        "ржХржиржЯрзЗржХрзНрж╕ржЯ:\n{context}\n\n"
        "ржЪрзНржпрж╛ржЯ рж╣рж┐рж╕рзНржЯрзНрж░рж┐:\n{chat_history}\n\n"
        "ржмрзНржпржмрж╣рж╛рж░ржХрж╛рж░рзА: {user_query}\nржмржЯ:"
    )
)


def validate_offer_price(response: str, products: List[dict]) -> str:
    """
    Validate the offered price in the bot's response to ensure it is not below the marginal price.
    If below, adjust to the marginal price of the most relevant product.
    """
    if not products:
        return response
    
    # Assume the first product is the most relevant
    marginal_price = float(products[0]["marginal_price"])
    print(f"Marginal price of the most relevant product: {marginal_price}")
    
    # Extract the offered price from the response (assuming format like "[number] ржЯрж╛ржХрж╛")
    match = re.search(r'(\d+\.?\d*)\s*ржЯрж╛ржХрж╛', response)
    if match:
        offered_price = float(match.group(1))
        if offered_price < marginal_price:
            # Replace the offered price with the marginal price
            response = re.sub(r'\d+\.?\d*\s*ржЯрж╛ржХрж╛', f"{int(marginal_price)} ржЯрж╛ржХрж╛", response)
    
    return response

def add_to_google_sheet(phone_number: str):
    try:
        scope = ["https://spreadsheets.google.com/feeds", "https://www.googleapis.com/auth/drive"]
        creds = Credentials.from_service_account_file("google_sheet.json", scopes=scope)
        client = gspread.authorize(creds)
        sheet = client.open_by_key("1eEuya073QSg0iXsued7e1xJbcrRdKuD7UH7JsyQLvS0").sheet1
        
        today_date = datetime.now().strftime("%Y-%m-%d")
        sheet.insert_row([phone_number, today_date], index=2) # index=2 to insert at the top after header
        print(f"Successfully added {phone_number} to Google Sheet.")
    except Exception as e:
        print(f"Error adding to Google Sheet: {e}")

@router.post("/api/chat")
async def chat(
    images: Optional[List[UploadFile]] = File(None),
    text: Optional[str] = Form(None),
    session_id: Optional[str] = Form(None)
):  
    # bot_response = "Hello"
    # return JSONResponse(content={
    #     "reply": bot_response,
    #     "related_products": [],
    #     "session_id": session_id
    # })
    if not images and not text:
        return JSONResponse(status_code=400, content={"error": "At least one image or text input is required"})
    


    
    session_id = session_id or str(uuid4())
    session_data = session_memories[session_id]
    memory = session_data["memory"]
    retrieved_products = session_data["last_products"]
    session_data["message_count"] += 1  # Increment message count

    # Define query early to allow conditional logic
    user_query = text.strip() if text else "ржЖржкрж▓рзЛржб ржХрж░рж╛ ржкржгрзНржпржЧрзБрж▓рзЛрж░ ржирж╛ржо ржПржмржВ ржорзВрж▓рзНржп ржкрзНрж░ржжрж╛ржи ржХрж░рзБржиред"

    # Image search - Process images FIRST, before checking for greetings
    if images:
        retrieved_products = []
        image_index = model_manager.get_image_index()
        image_metadata = model_manager.get_image_metadata()
        
        if image_index is None or not image_metadata:
            return JSONResponse(status_code=500, content={"error": "Image search not available"})
            
        for image_file in images:
            image = Image.open(image_file.file)
            image_embedding = model_manager.get_image_embedding(image)
            D, I = image_index.search(np.array([image_embedding]).astype('float32'), k=1)
            retrieved_products.append(image_metadata[I[0][0]])
        session_data["last_products"] = retrieved_products

    print("retrieved_products:", retrieved_products)

    # Handle greeting/price query for first-time users with no product context
    # CHECK THIS AFTER image processing but BEFORE text search
    if not retrieved_products and any(k in user_query.lower() for k in ["pp", "price", "assalamu alaiikum", "salam", "ржЖрж╕рж╕рж╛рж▓рж╛ржорзБ ржЖрж▓рж╛ржЗржХрзБржо", "ржкрзНрж░рж╛ржЗржЬ", "ржжрж╛ржо", "ржорзВрж▓рзНржп", "hi", "hello", "hey", "рж╣рж╛ржЗ", "рж╣рзНржпрж╛рж▓рзЛ", "рж╣рзЗрж▓рзЛ", ".", "ЁЯШК", "ЁЯШВ", "тЭдя╕П", "ЁЯСН", "ЁЯЩП", "ЁЯдй", "ЁЯШБ", "ЁЯШЮ", "ЁЯФе", "тЬи", "ЁЯОЙ"]):
        bot_response = "ржЖрж╕рж╕рж╛рж▓рж╛ржорзБ ржЖрж▓рж╛ржЗржХрзБржо...\n\nржЖржкржирж┐ ржпрзЗ ржкрзНрж░рзЛржбрж╛ржХрзНржЯ ржЯрж┐ рж╕ржорзНржкрж░рзНржХрзЗ ржЬрж╛ржирждрзЗ ржЪрж╛ржЪрзНржЫрзЗржи, ржжрзЯрж╛ ржХрж░рзЗ ржЫржмрж┐ ржжрж┐ржиред"
        return JSONResponse(content={
            "reply": bot_response,
            "related_products": [],
            "session_id": session_id
        })

    # Text search - now this block runs ONLY if the greeting condition was NOT met, and if 'text' is provided
    if text:
        text_vector_store = model_manager.get_text_vector_store()
        if text_vector_store is None:
            return JSONResponse(status_code=500, content={"error": "Text search not available"})
            
        docs = text_vector_store.similarity_search(text, k=1)
        for doc in docs:
            retrieved_products.append(doc.metadata)
        session_data["last_products"] = retrieved_products

    # Remove duplicates
    seen_products = set()
    unique_products = []
    for product in retrieved_products:
        identifier = (product.get('name', '').strip(), product.get('code', '').strip())
        if identifier not in seen_products:
            seen_products.add(identifier)
            unique_products.append(product)
    retrieved_products = unique_products

    # Build context
    context = "\nAvailable products:\n"
    for product in retrieved_products:
        context += f"- Name: {product['name']}, Price: {product['price']},Description: {product['description']} Link: {product['link']}\n"

    # Check for phone number and save to Google Sheet
    phone_pattern = r'(?:\d{8,11}|[рзж-рзп]{8,11})'
    match = re.search(phone_pattern, user_query)
    if match:
        phone_number = match.group(0)
        add_to_google_sheet(phone_number)

    llm = model_manager.get_llm()
    chain = RunnableSequence(prompt | llm)
    chat_history = memory.load_memory_variables({})["chat_history"]
    inputs = {"chat_history": chat_history, "user_query": user_query, "context": context}
    print(inputs)
    response = chain.invoke(inputs)
    bot_response = response.content
    print("Raw bot response:", bot_response)

    # Increment message count in database
    try:
        with db_service.get_cursor() as (cursor, connection):
            cursor.execute("UPDATE business_settings SET value = value + 1 WHERE `key` = 'number_of_message'")
            connection.commit()
    except Exception as e:
        print(f"Error incrementing message count: {e}")

    # Save to memory
    memory.save_context({"user_query": user_query}, {"output": bot_response})

    # Check if message count has reached 15 and clear memory if so
    if session_data["message_count"] >= 20:
        session_memories[session_id] = {
            "memory": ConversationBufferMemory(memory_key="chat_history", return_messages=True),
            "last_products": [],
            "message_count": 0
        }
        print(f"Session memory cleared for session_id: {session_id} after 15 messages")

    return JSONResponse(content={
        "reply": bot_response,
        "related_products": [{k: v for k, v in product.items() if k != "marginal_price"} for product in retrieved_products],
        "session_id": session_id
    })

def send_to_facebook(recipient_id: str, message_text: str = None, image_url: str = None):
    """Send message or image back to user via Facebook Graph API."""
    if image_url:
        payload = {
            "messaging_type": "RESPONSE",
            "recipient": {"id": recipient_id},
            "message": {
                "attachment": {
                    "type": "image",
                    "payload": {
                        "url": image_url,
                        "is_reusable": True
                    }
                }
            }
        }
    else:
        payload = {
            "messaging_type": "RESPONSE",
            "recipient": {"id": recipient_id},
            "message": {"text": message_text}
        }
    
    response = requests.post(
        settings.FB_GRAPH_URL,
        json=payload,
        headers={"Content-Type": "application/json"}
    )
    if response.status_code != 200:
        print(f"Error sending message: {response.text}")
    return response.status_code == 200

@router.get("/webhook")
async def verify_webhook(request: Request):
    mode = request.query_params.get("hub.mode")
    token = request.query_params.get("hub.verify_token")
    challenge = request.query_params.get("hub.challenge")
    
    print(f"VERIFY_TOKEN: {settings.VERIFY_TOKEN}, Received token: {token}")
    if mode == "subscribe" and token == settings.VERIFY_TOKEN:
        return Response(content=str(challenge), status_code=200)
    else:
        raise HTTPException(status_code=403, detail="Forbidden")

@router.post("/webhook")
async def receive_webhook(request: Request):
    data = await request.json()

    if data.get("object") != "page":
        return JSONResponse(status_code=200, content={"status": "ok"})

    for entry in data.get("entry", []):
        messaging = entry.get("messaging", [])
        for message_data in messaging:
            timestamp_ms = message_data.get("timestamp")
            if timestamp_ms:
                msg_time = datetime.fromtimestamp(timestamp_ms / 1000.0)
                if datetime.utcnow() - msg_time > timedelta(minutes=1):
                    print(f"тЪая╕П Ignoring old message from {msg_time}")
                    continue

            mid = message_data.get("message", {}).get("mid")
            if mid and mid in processed_messages:
                print(f"Duplicate message ignored: {mid}")
                continue
            if mid:
                processed_messages.add(mid)
    
                if len(processed_messages) > 100:
                    processed_messages.clear()
            sender_id = message_data["sender"]["id"]
            print("Received message_data:", message_data)
            incoming_msg = message_data["message"].get("text", "")
            files = []
            attachments = message_data["message"].get("attachments", [])
            if attachments:
                for idx, attachment in enumerate(attachments):
                    if attachment["type"] == "image":
                        image_url = attachment["payload"]["url"]
                        async with httpx.AsyncClient() as client:
                            image_response = await client.get(image_url)
                            if image_response.status_code == 200:
                                image_content = image_response.content
                                files.append(
                                    (
                                        "images",  
                                        (f"image_{sender_id}_{idx}.jpg", image_content, "image/jpeg")
                                    )
                                )
                            else:
                                print(f" Failed to download image: {image_response.status_code}")
            

            if not incoming_msg and not files:
                send_to_facebook(sender_id, "Please send a text message or an image to search for products.")
                continue

            session_id = sender_id
            async with httpx.AsyncClient() as client:
                print("Sending to /chat:", {"text": incoming_msg, "session_id": session_id, "files_count": len(files)})
                try:
                    if files:
                        response = await client.post(
                            "https://chat.momsandkidsworld.com/api/chat",
                            data={"text": incoming_msg, "session_id": session_id},
                            files=files,
                            timeout=30.0
                        )
                    else:
                        response = await client.post(
                            "https://chat.momsandkidsworld.com/api/chat",
                            data={"text": incoming_msg, "session_id": session_id},
                            timeout=30.0
                        )
                except httpx.RequestError as e:
                    print(f"Network error calling /chat: {e}")
                    send_to_facebook(sender_id, "Sorry, something went wrong while connecting to the chat server.")
                    continue
                if response.status_code != 200:
                    print(f"Error from /chat: {response.status_code}, {response.text}")
                    bot_reply = "Sorry, something went wrong."
                else:
                    result = response.json()
                    bot_reply = result.get("reply", "Sorry, I didnтАЩt understand that.")

            send_to_facebook(sender_id, bot_reply)

    return JSONResponse(status_code=200, content={"status": "ok"})