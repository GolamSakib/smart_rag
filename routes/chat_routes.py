from fastapi import APIRouter, File, UploadFile, Form, HTTPException, Request, Response
from fastapi.responses import JSONResponse
from PIL import Image
from typing import List, Optional
from langchain.memory import ConversationBufferMemory
from langchain.prompts import PromptTemplate
from langchain_core.runnables import RunnableSequence
from uuid import uuid4
from collections import defaultdict
import numpy as np
import httpx
import requests
import re
import gspread
from google.oauth2.service_account import Credentials
from datetime import datetime

from services.model_manager import model_manager
from config.settings import settings
from services.database_service import db_service

router = APIRouter()

# In-memory store for per-session memory
session_memories = defaultdict(lambda: {
    "memory": ConversationBufferMemory(memory_key="chat_history", return_messages=True),
    "last_products": []  # Store last retrieved products
})

# Updated Prompt template with discount calculation rule
prompt = PromptTemplate(
    input_variables=["chat_history", "user_query", "context"],
    template=(
        "ржЖржкржирж┐ ржПржХржЬржи ржмржирзНржзрзБрждрзНржмржкрзВрж░рзНржг ржПржмржВ ржкрзЗрж╢рж╛ржжрж╛рж░ ржмрж┐ржХрзНрж░ржпрж╝ рж╕рж╣ржХрж╛рж░рзАред ржкрзНрж░рждрж┐ржЯрж┐ ржХржерзЛржкржХржержирзЗрж░ ржкрзНрж░ржержо ржмрж╛рж░рзНрждрж╛ржпрж╝ ржорзБрж╕рж▓рж┐ржо рж╕рж╛ржВрж╕рзНржХрзГрждрж┐ржХ рж░рзАрждрж┐ ржЕржирзБрж╕рж╛рж░рзЗ ржЗрж╕рж▓рж╛ржорж┐ржХ ржЕржнрж┐ржмрж╛ржжржи 'ржЖрж╕рж╕рж╛рж▓рж╛ржорзБ ржЖрж▓рж╛ржЗржХрзБржо' ржжрж┐ржпрж╝рзЗ рж╢рзБрж░рзБ ржХрж░рзБржиред ржкрж░ржмрж░рзНрждрзА ржмрж╛рж░рзНрждрж╛ржЧрзБрж▓рзЛрждрзЗ ржПржЗ ржЕржнрж┐ржмрж╛ржжржи ржмрзНржпржмрж╣рж╛рж░ ржХрж░ржмрзЗржи ржирж╛, ржпржжрж┐ ржирж╛ ржмрзНржпржмрж╣рж╛рж░ржХрж╛рж░рзА рж╕рзНржкрж╖рзНржЯржнрж╛ржмрзЗ ржПржЯрж┐ ржЕржирзБрж░рзЛржз ржХрж░рзЗржиред рж╕ржм ржЙрждрзНрждрж░ ржмрж╛ржВрж▓рж╛ржпрж╝ рж╣ржмрзЗ, рж╕ржВржХрзНрж╖рж┐ржкрзНржд, ржЖржХрж░рзНрж╖ржгрзАржпрж╝ ржПржмржВ ржмрзЛржЭрж╛ржирзЛрж░ ржорждрзЛ ржЯрзЛржи ржмржЬрж╛ржпрж╝ рж░рж╛ржЦрзБржи ржпрж╛рждрзЗ ржХрзНрж░ржпрж╝ ржЙрзОрж╕рж╛рж╣рж┐ржд рж╣ржпрж╝ред\n"
        "ржХржиржЯрзЗржХрзНрж╕ржЯрзЗ ржжрзЗржУржпрж╝рж╛ ржкржгрзНржпрзЗрж░ ржмрж┐ржмрж░ржг (ржирж╛ржо, ржорзВрж▓рзНржп, рж▓рж┐ржЩрзНржХ) ржарж┐ржХ ржпрзЗржоржи ржЖржЫрзЗ рждрзЗржоржи рж░рж╛ржЦрзБржи, ржХрзЛржирзЛ ржЕржирзБржмрж╛ржж ржХрж░ржмрзЗржи ржирж╛ред\n"
        "ржпржЦржиржЗ ржХрзЛржирзЛ ржкржгрзНржпрзЗрж░ ржмрж┐ржмрж░ржг ржмрж╛ ржорзВрж▓рзНржп ржЙрж▓рзНрж▓рзЗржЦ ржХрж░ржмрзЗржи, рждржЦржи ржмрзНржпржмрж╣рж╛рж░ржХрж╛рж░рзАржХрзЗ ржУржпрж╝рзЗржмрж╕рж╛ржЗржЯрзЗ ржкржгрзНржпржЯрж┐ ржжрзЗржЦрждрзЗ ржЙрзОрж╕рж╛рж╣рж┐ржд ржХрж░рзБржиред ржмрж▓рзБржи 'ржЖржкржирж┐ ржЖржорж╛ржжрзЗрж░ ржУржпрж╝рзЗржмрж╕рж╛ржЗржЯрзЗ ржкржгрзНржпржЯрж┐ ржжрзЗржЦрждрзЗ ржкрж╛рж░рзЗржи' ржПржмржВ рж▓рж┐ржЩрзНржХржЯрж┐ рж╕рж░ржмрж░рж╛рж╣ ржХрж░рзБржиред ржПржЯрж┐ ржмрзНржпржмрж╣рж╛рж░ржХрж╛рж░рзАржХрзЗ ржкржгрзНржпржЯрж┐ ржХрж┐ржирждрзЗ ржЖрж░ржУ ржЖржЧрзНрж░рж╣рзА ржХрж░ржмрзЗред\n"
        "ржХржиржЯрзЗржХрзНрж╕ржЯ ржПржмржВ ржЪрзНржпрж╛ржЯ рж╣рж┐рж╕рзНржЯрзНрж░рж┐ ржмрзНржпржмрж╣рж╛рж░ ржХрж░рзЗ ржмрзНржпржмрж╣рж╛рж░ржХрж╛рж░рзАрж░ ржкрзНрж░рж╢рзНржирзЗрж░ рж╕ржарж┐ржХ ржПржмржВ ржЖржХрж░рзНрж╖ржгрзАржпрж╝ ржЙрждрзНрждрж░ ржжрж┐ржиред\n"
        "рж╢рзБржзрзБржорж╛рждрзНрж░ ржмрзНржпржмрж╣рж╛рж░ржХрж╛рж░рзА рж╕рзНржкрж╖рзНржЯржнрж╛ржмрзЗ ржкржгрзНржпрзЗрж░ ржмрж░рзНржгржирж╛ ржЪрж╛ржЗрж▓рзЗ (ржпрзЗржоржи, 'description', 'ржмрж░рзНржгржирж╛', 'details', 'ржмрж┐рж╕рзНрждрж╛рж░рж┐ржд' рж╢ржмрзНржж ржмрзНржпржмрж╣рж╛рж░ ржХрж░рж▓рзЗ) ржкржгрзНржпрзЗрж░ ржмрж░рзНржгржирж╛ ржЕржирзНрждрж░рзНржнрзБржХрзНржд ржХрж░рзБржиред рждржЦржи ржЕржмрж╢рзНржпржЗ ржирж┐ржЪрзЗрж░ рждржерзНржпржЯрж┐ ржпрзЛржЧ ржХрж░рждрзЗ рж╣ржмрзЗ:\n"
        "'ржЖржорж╛ржжрзЗрж░ ржмрзНржпрж╛ржЧржЧрзБрж▓рзЛ рж╕рж░рж╛рж╕рж░рж┐ ржЪрж╛рзЯржирж╛ ржУ ржерж╛ржЗрж▓рзНржпрж╛ржирзНржб ржерзЗржХрзЗ ржЗржорзНржкрзЛрж░рзНржЯ ржХрж░рж╛ тАФ ржХрзЛрзЯрж╛рж▓рж┐ржЯрж┐рждрзЗ ржХрзЛржирзЛ ржЖржкрж╕ ржирзЯ! ржкрзНрж░рждрж┐ржЯрж┐ ржмрзНржпрж╛ржЧ рждрзИрж░рж┐ ржХрж░рж╛ рж╣рзЯрзЗржЫрзЗ High Quality PU Leather ржжрж┐рзЯрзЗ, ржпрж╛ рж╣рж╛рждрзЗрж░ рж╕рзНржкрж░рзНрж╢рзЗржЗ ржмрзБржЭрждрзЗ ржкрж╛рж░ржмрзЗржи ржПрж░ ржкрзНрж░рж┐ржорж┐рзЯрж╛ржо ржлрж┐ржирж┐рж╢рж┐ржВ! ржЖржорж╛ржжрзЗрж░ ржмрзНржпрж╛ржЧржЧрзБрж▓рзЛ ржПрждржЯрж╛ржЗ ржЯрзЗржХрж╕ржЗ ржпрзЗ, рзк-рзл ржмржЫрж░рзЗржУ ржЙржарзЗ ржпрж╛ржмрзЗ ржирж╛ ржмрж╛ ржирж╖рзНржЯ рж╣ржмрзЗ ржирж╛ ржЗржирж╢рж╛ржЖрж▓рзНрж▓рж╛рж╣ред рж╕рзНржЯрж╛ржЗрж▓ ржЖрж░ рж╕рзНржерж╛рзЯрж┐рждрзНржмтАФржжрзБржЯрзЛржЗ ржПржХрж╕рж╛ржерзЗ! ржЖржкржирж┐ ржмрзНржпрж╛ржЧржЧрзБрж▓рзЛ ржЕржирзЗржХ ржмржЫрж░ ржзрж░рзЗ ржирж┐рж╢рзНржЪрж┐ржирзНрждрзЗ ржмрзНржпржмрж╣рж╛рж░ ржХрж░рждрзЗ ржкрж╛рж░ржмрзЗржиред'\n"
        "ржпржжрж┐ ржмрзНржпржмрж╣рж╛рж░ржХрж╛рж░рзА ржЫржмрж┐ ржЖржкрж▓рзЛржб ржХрж░рзЗржи ржмрж╛ ржХрзЛржирзЛ ржкржгрзНржп рж╕ржорзНржкрж░рзНржХрзЗ ржЬрж┐ржЬрзНржЮрж╛рж╕рж╛ ржХрж░рзЗржи, рждржмрзЗ ржкржгрзНржпрзЗрж░ ржирж╛ржо ржПржмржВ ржорзВрж▓рзНржп (ржЯрж╛ржХрж╛ржпрж╝) ржЕржирзНрждрж░рзНржнрзБржХрзНржд ржХрж░рзБржи, ржПржмржВ ржмрж░рзНржгржирж╛ рж╢рзБржзрзБржорж╛рждрзНрж░ рждржЦржиржЗ ржжрж┐ржи ржпржжрж┐ ржмрзНржпржмрж╣рж╛рж░ржХрж╛рж░рзА рж╕рзНржкрж╖рзНржЯржнрж╛ржмрзЗ ржмрж░рзНржгржирж╛ ржЪрж╛ржиред\n"
        "ржпржжрж┐ ржмрзНржпржмрж╣рж╛рж░ржХрж╛рж░рзА ржкржгрзНржпрзЗрж░ ржЫржмрж┐ ржжрзЗржЦрждрзЗ ржЪрж╛ржи (ржпрзЗржоржи, 'image dekhte chai', 'chobi dekhan', ржмрж╛ ржЕржирзБрж░рзВржк), рждржмрзЗ ржмрж╛ржВрж▓рж╛ржпрж╝ ржЙрждрзНрждрж░ ржжрж┐ржи: "
        "'ржкржгрзНржпрзЗрж░ ржЫржмрж┐ ржжрзЗржЦрждрзЗ ржЖржорж╛ржжрзЗрж░ WhatsApp ржирж╛ржорзНржмрж╛рж░рзЗ ржпрзЛржЧрж╛ржпрзЛржЧ ржХрж░рзБржи: 01942550295 рж╕рзЗржЦрж╛ржирзЗ ржЖржкржирж╛ржХрзЗ ржкржгрзНржпрзЗрж░ ржмрж┐рж╕рзНрждрж╛рж░рж┐ржд ржЫржмрж┐ ржкрж╛ржарж╛ржирзЛ рж╣ржмрзЗред'\n"
        "ржпржжрж┐ ржмрзНржпржмрж╣рж╛рж░ржХрж╛рж░рзА 'pp', 'price', ржмрж╛ ржЕржирзБрж░рзВржк ржХрж┐ржЫрзБ (ржХрзЗрж╕-ржЗржирж╕рзЗржирж╕рж┐ржЯрж┐ржн) ржЬрж┐ржЬрзНржЮрж╛рж╕рж╛ ржХрж░рзЗржи, рждржмрзЗ ржХржиржЯрзЗржХрзНрж╕ржЯ ржерзЗржХрзЗ рж╕ржмржЪрзЗржпрж╝рзЗ ржкрзНрж░рж╛рж╕ржЩрзНржЧрж┐ржХ ржкржгрзНржпрзЗрж░ ржорзВрж▓рзНржп рж╢рзБржзрзБржорж╛рждрзНрж░ ржЯрж╛ржХрж╛ржпрж╝ ржЙрж▓рзНрж▓рзЗржЦ ржХрж░рзБржиред\n"
        "ржпржжрж┐ ржмрзНржпржмрж╣рж╛рж░ржХрж╛рж░рзА ржЬрж┐ржЬрзНржЮрж╛рж╕рж╛ ржХрж░рзЗржи ржкржгрзНржпржЯрж┐ ржЫржмрж┐рж░ ржорждрзЛ ржХрж┐ржирж╛ (ржпрзЗржоржи, 'hubohu chobir moto'), рждржмрзЗ ржмрж╛ржВрж▓рж╛ржпрж╝ ржЙрждрзНрждрж░ ржжрж┐ржи: "
        "'рж╣рзНржпрж╛ржБ, ржкржгрзНржп ржПржХржжржо рж╣рзБржмрж╣рзБ ржЫржмрж┐рж░ ржорждрзЛ! ржЖржорж░рж╛ ржЧрзНржпрж╛рж░рж╛ржирзНржЯрж┐ ржжрж┐ржЪрзНржЫрж┐, ржЫржмрж┐рждрзЗ ржпрж╛ ржжрзЗржЦржЫрзЗржи, ржарж┐ржХ рждрж╛ржЗ ржкрж╛ржмрзЗржиред'\n"
        "ржпржжрж┐ ржмрзНржпржмрж╣рж╛рж░ржХрж╛рж░рзА ржЕрж░рзНржбрж╛рж░ ржХрж░рждрзЗ ржЪрж╛ржи, рждржмрзЗ ржЕрж░рзНржбрж╛рж░ ржЪрзВржбрж╝рж╛ржирзНржд ржХрж░рждрзЗ ржмрж╛ржВрж▓рж╛ржпрж╝ ржЙрждрзНрждрж░ ржжрж┐ржи: "
        "'ЁЯУж ржЕрж░рзНржбрж╛рж░ ржХржиржлрж╛рж░рзНржо ржХрж░рждрзЗ ржжржпрж╝рж╛ ржХрж░рзЗ ржирж┐ржЪрзЗрж░ рждржерзНржп ржжрж┐ржи:\n"
        "ЁЯСд ржирж╛ржо\n"
        "ЁЯПа ржарж┐ржХрж╛ржирж╛\n"
        "ЁЯУ▒ ржорзЛржмрж╛ржЗрж▓ ржирж╛ржорзНржмрж╛рж░\n"
        "ЁЯТ░ ржХрзЛржирзЛ ржЕржЧрзНрж░рж┐ржо ржкрзЗржорзЗржирзНржЯ ржирзЗржЗ! ржкржгрзНржп рж╣рж╛рждрзЗ ржкрзЗржпрж╝рзЗ ржЪрзЗржХ ржХрж░рзЗ ржХрзНржпрж╛рж╢ ржЕржи ржбрзЗрж▓рж┐ржнрж╛рж░рж┐рждрзЗ ржкрзЗржорзЗржирзНржЯ ржХрж░рзБржиред\n"
        "ржЕрж░рзНржбрж╛рж░ ржЯрзНрж░рзНржпрж╛ржХ ржХрж░рждрзЗ ржЖржорж╛ржжрзЗрж░ WhatsApp ржирж╛ржорзНржмрж╛рж░рзЗ ржпрзЛржЧрж╛ржпрзЛржЧ ржХрж░рзБржи: 01942550295'\n"
        "ржпржжрж┐ ржмрзНржпржмрж╣рж╛рж░ржХрж╛рж░рзА ржЕрж░рзНржбрж╛рж░ ржЯрзНрж░рзНржпрж╛ржХ ржХрж░рждрзЗ ржЪрж╛ржи (ржпрзЗржоржи, 'order track korte chai', 'order kothay', ржмрж╛ ржЕржирзБрж░рзВржк), рждржмрзЗ ржмрж╛ржВрж▓рж╛ржпрж╝ ржЙрждрзНрждрж░ ржжрж┐ржи: "
        "'ржЖржкржирж╛рж░ ржЕрж░рзНржбрж╛рж░ ржЯрзНрж░рзНржпрж╛ржХ ржХрж░рждрзЗ ржЖржорж╛ржжрзЗрж░ WhatsApp ржирж╛ржорзНржмрж╛рж░рзЗ ржпрзЛржЧрж╛ржпрзЛржЧ ржХрж░рзБржи: 01942550295 ржЖржорж░рж╛ ржЖржкржирж╛ржХрзЗ ржжрзНрж░рзБржд ржЖржкржбрзЗржЯ ржЬрж╛ржирж╛ржмред'\n"
        "ржпржжрж┐ ржмрзНржпржмрж╣рж╛рж░ржХрж╛рж░рзА ржжрж░ржжрж╛ржо ржХрж░рждрзЗ ржЪрж╛ржи (ржпрзЗржоржи, 'dam komano jay kina', 'ektu komano jay na', 'dam ta onk beshi', ржмрж╛ ржЕржирзБрж░рзВржк), рждржмрзЗ ржмрж╛ржВрж▓рж╛ржпрж╝ ржЖржХрж░рзНрж╖ржгрзАржпрж╝ржнрж╛ржмрзЗ ржЙрждрзНрждрж░ ржжрж┐ржи: "
        "'ржЖржорж░рж╛ рж╕ржмрж╕ржоржпрж╝ рж╕рзЗрж░рж╛ ржорзВрж▓рзНржпрзЗ ржкржгрзНржп ржмрж┐ржХрзНрж░рж┐ ржХрж░рж┐, ржПржмржВ ржПрж░ ржерзЗржХрзЗ ржХржорж╛ржирзЛ рж╕ржорзНржнржм ржиржпрж╝ред рждржмрзЗ ржЖржорж╛ржжрзЗрж░ ржкржгрзНржпрзЗрж░ ржЧрзБржгржорж╛ржи ржУ рж╕рзЗржмрж╛рж░ ржирж┐рж░рзНржнрж░ржпрзЛржЧрзНржпрждрж╛ ржЖржкржирж╛ржХрзЗ ржирж┐рж╢рзНржЪрж┐рждржнрж╛ржмрзЗ рж╕ржирзНрждрзБрж╖рзНржЯ ржХрж░ржмрзЗ! ржПржЦржиржЗ ржЕрж░рзНржбрж╛рж░ ржХрж░рж▓рзЗ ржжрзНрж░рзБржд ржбрзЗрж▓рж┐ржнрж╛рж░рж┐ ржирж┐рж╢рзНржЪрж┐рждред'\n"
        "ржпржжрж┐ ржмрзНржпржмрж╣рж╛рж░ржХрж╛рж░рзА ржбрзЗрж▓рж┐ржнрж╛рж░рж┐ рж╕ржорзНржкрж░рзНржХрзЗ ржЬрж┐ржЬрзНржЮрж╛рж╕рж╛ ржХрж░рзЗржи, рждржмрзЗ ржмрж╛ржВрж▓рж╛ржпрж╝ ржЙрждрзНрждрж░ ржжрж┐ржи: "
        "'ЁЯЪЪ ржЖржорж░рж╛ рж╕рж╛рж░рж╛ ржмрж╛ржВрж▓рж╛ржжрзЗрж╢рзЗ ржХрзНржпрж╛рж╢ ржЕржи ржбрзЗрж▓рж┐ржнрж╛рж░рж┐ рж╕рзБржмрж┐ржзрж╛ ржжрж┐ржЪрзНржЫрж┐:\n"
        "ЁЯПа ржврж╛ржХрж╛рж░ ржоржзрзНржпрзЗ: ржбрзЗрж▓рж┐ржнрж╛рж░рж┐ ржЪрж╛рж░рзНржЬ рзорзж ржЯрж╛ржХрж╛, рзз-рзи ржжрж┐ржирзЗрж░ ржоржзрзНржпрзЗ ржкрзМржБржЫрзЗ ржпрж╛ржмрзЗред\n"
        "ЁЯЪЪ ржврж╛ржХрж╛рж░ ржмрж╛ржЗрж░рзЗ: ржбрзЗрж▓рж┐ржнрж╛рж░рж┐ ржЪрж╛рж░рзНржЬ рззрзирзж ржЯрж╛ржХрж╛, рзи-рзй ржжрж┐ржирзЗрж░ ржоржзрзНржпрзЗ ржкрзМржБржЫрзЗ ржпрж╛ржмрзЗ, ржЗржирж╢рж╛ржЖрж▓рзНрж▓рж╛рж╣ред\n"
        "ЁЯСА ржкржгрзНржп рж╣рж╛рждрзЗ ржкрзЗржпрж╝рзЗ ржЪрзЗржХ ржХрж░рзБржи, рждрж╛рж░ржкрж░ ржкрзЗржорзЗржирзНржЯ ржХрж░рзБржиред\n"
        "ЁЯОБ ржкрзНрж░рждрж┐ржЯрж┐ ржЕрж░рзНржбрж╛рж░рзЗ ржжрзНрж░рзБржд ржУ ржирж┐рж░рзНржнрж░ржпрзЛржЧрзНржп ржбрзЗрж▓рж┐ржнрж╛рж░рж┐ ржирж┐рж╢рзНржЪрж┐рждред'\n"
        "ржпржжрж┐ ржмрзНржпржмрж╣рж╛рж░ржХрж╛рж░рзА ржбрзЗрж▓рж┐ржнрж╛рж░рж┐ ржЪрж╛рж░рзНржЬрж╕рж╣ ржорзЛржЯ ржорзВрж▓рзНржп ржЬрж╛ржирждрзЗ ржЪрж╛ржи (ржпрзЗржоржи, 'delivery charge soho koto porbe'), рждржмрзЗ ржкржгрзНржпрзЗрж░ рждрж╛рж▓рж┐ржХрж╛ржнрзБржХрзНржд ржорзВрж▓рзНржпрзЗрж░ рж╕рж╛ржерзЗ ржбрзЗрж▓рж┐ржнрж╛рж░рж┐ ржЪрж╛рж░рзНржЬ (ржврж╛ржХрж╛ржпрж╝ рзорзж ржЯрж╛ржХрж╛, ржврж╛ржХрж╛рж░ ржмрж╛ржЗрж░рзЗ рззрзирзж ржЯрж╛ржХрж╛) ржпрзЛржЧ ржХрж░рзБржи ржПржмржВ ржмрж╛ржВрж▓рж╛ржпрж╝ ржЙрждрзНрждрж░ ржжрж┐ржи, ржпрзЗржоржи: "
        "'ржкржгрзНржпрзЗрж░ ржжрж╛ржо [product price] ржЯрж╛ржХрж╛, ржбрзЗрж▓рж┐ржнрж╛рж░рж┐ ржЪрж╛рж░рзНржЬ [80/120] ржЯрж╛ржХрж╛ рж╕рж╣ ржорзЛржЯ [total price] ржЯрж╛ржХрж╛ред ржПржЦржиржЗ ржЕрж░рзНржбрж╛рж░ ржХрж░рзБржи!'\n"
        "ржкржгрзНржпрзЗрж░ ржЧрзБржгржорж╛ржи, ржирж┐рж░рзНржнрж░ржпрзЛржЧрзНржпрждрж╛ ржПржмржВ ржЬрж░рзБрж░рж┐ ржнрж┐рждрзНрждрж┐рждрзЗ ржЕрж░рзНржбрж╛рж░рзЗрж░ ржЖржХрж░рзНрж╖ржг ржмрж╛ржбрж╝рж╛ржиред\n\n"
        "ржХржиржЯрзЗржХрзНрж╕ржЯ:\n{context}\n\n"
        "ржЪрзНржпрж╛ржЯ рж╣рж┐рж╕рзНржЯрзНрж░рж┐:\n{chat_history}\n\n"
        "ржмрзНржпржмрж╣рж╛рж░ржХрж╛рж░рзА: {user_query}\nржмржЯ: "
    )
)



def validate_offer_price(response: str, products: List[dict]) -> str:
    """
    Validate the offered price in the bot's response to ensure it is not below the marginal price.
    If below, adjust to the marginal price of the most relevant product.
    """
    if not products:
        return response
    
    # Assume the first product is the most relevant
    marginal_price = float(products[0]["marginal_price"])
    print(f"Marginal price of the most relevant product: {marginal_price}")
    
    # Extract the offered price from the response (assuming format like "[number] ржЯрж╛ржХрж╛")
    match = re.search(r'(\d+\.?\d*)\s*ржЯрж╛ржХрж╛', response)
    if match:
        offered_price = float(match.group(1))
        if offered_price < marginal_price:
            # Replace the offered price with the marginal price
            response = re.sub(r'\d+\.?\d*\s*ржЯрж╛ржХрж╛', f"{int(marginal_price)} ржЯрж╛ржХрж╛", response)
    
    return response

@router.post("/api/chat")
async def chat(
    images: Optional[List[UploadFile]] = File(None),
    text: Optional[str] = Form(None),
    session_id: Optional[str] = Form(None)
):
    if not images and not text:
        return JSONResponse(status_code=400, content={"error": "At least one image or text input is required"})
    
    session_id = session_id or str(uuid4())
    session_data = session_memories[session_id]
    memory = session_data["memory"]
    retrieved_products = session_data["last_products"]

    # Image search
    if images:
        retrieved_products = []
        image_index = model_manager.get_image_index()
        image_metadata = model_manager.get_image_metadata()
        
        if image_index is None or not image_metadata:
            return JSONResponse(status_code=500, content={"error": "Image search not available"})
            
        for image_file in images:
            image = Image.open(image_file.file)
            image_embedding = model_manager.get_image_embedding(image)
            D, I = image_index.search(np.array([image_embedding]).astype('float32'), k=1)
            retrieved_products.append(image_metadata[I[0][0]])
            print("")
        session_data["last_products"] = retrieved_products

    # Text search
    if text:
        text_vector_store = model_manager.get_text_vector_store()
        if text_vector_store is None:
            return JSONResponse(status_code=500, content={"error": "Text search not available"})
            
        docs = text_vector_store.similarity_search(text, k=1)
        for doc in docs:
            retrieved_products.append(doc.metadata)
        session_data["last_products"] = retrieved_products

    # Remove duplicates
    seen_products = set()
    unique_products = []
    for product in retrieved_products:
        identifier = (product.get('name', '').strip(), product.get('code', '').strip())
        if identifier not in seen_products:
            seen_products.add(identifier)
            unique_products.append(product)
    retrieved_products = unique_products

    # Build context
    context = "\nAvailable products:\n"
    for product in retrieved_products:
        context += f"- Name: {product['name']}, Price: {product['price']}, Link: {product['link']}\n"
    print(context)

    # Define query
    user_query = text.strip() if text else "ржЖржкрж▓рзЛржб ржХрж░рж╛ ржкржгрзНржпржЧрзБрж▓рзЛрж░ ржирж╛ржо ржПржмржВ ржорзВрж▓рзНржп ржкрзНрж░ржжрж╛ржи ржХрж░рзБржиред"

    if any(k in user_query.lower() for k in ["hubohu", "exactly like", "same as picture", "ржЫржмрж┐рж░ ржоржд", "рж╣рзБржмрж╣рзБ"]):
        bot_response = "рж╣рзНржпрж╛ржБ, ржкржгрзНржп ржПржХржжржо рж╣рзБржмрж╣рзБ ржЫржмрж┐рж░ ржорждрзЛ рж╣ржмрзЗ! ржЖржорж░рж╛ ржирж┐рж╢рзНржЪрж┐ржд ржХрж░рж┐ ржпрзЗ ржЖржкржирж┐ ржЫржмрж┐рждрзЗ ржпрж╛ ржжрзЗржЦржЫрзЗржи, ржарж┐ржХ рждрзЗржоржиржЯрж╛ржЗ ржкрж╛ржмрзЗржиред"
    else:
        llm = model_manager.get_llm()
        chain = RunnableSequence(prompt | llm)
        chat_history = memory.load_memory_variables({})["chat_history"]
        inputs = {"chat_history": chat_history, "user_query": user_query, "context": context}
        print(inputs)
        response = chain.invoke(inputs)
        bot_response = response.content

    phone_number_pattern = re.compile(r'(?:\d{8,11}|[рзж-рзп]{8,11})')
    phone_match = phone_number_pattern.search(bot_response)
    if phone_match:
        phone_number = phone_match.group(0)
        try:
            # Authenticate with Google Sheets
        # Authenticate with Google Sheets
          scope = ['https://spreadsheets.google.com/feeds', 'https://www.googleapis.com/auth/drive']
          creds = Credentials.from_service_account_file('google_sheet.json', scopes=scope)
          client = gspread.authorize(creds)

        # Open the sheet and append the data
          sheet = client.open_by_key("1eEuya073QSg0iXsued7e1xJbcrRdKuD7UH7JsyQLvS0").sheet1
          today_date = datetime.now().strftime('%Y-%m-%d')
          sheet.append_row([phone_number, today_date])
          print(f"Successfully sent phone number {phone_number} and date {today_date} to Google Sheet.")
        except Exception as e:
            print(f"Error sending data to Google Sheet: {e}")
        
    #     bargaining_keywords = [
    #     "dam komano", "ektu komano", "dam ta onk", "eto dam kno", "komano jay kina", "komano jay na",
    #     "dam kombe", "kom koren", "kom kore den", "dam onik beshi", "onek dami", "koto discount",
    #     "discount pabo", "sera dam", "offer ache", "kom korun", "dam beshi", "kom dame", "discount din",
    #     "price reduce", "bargain", "too expensive", "lower price", "can you reduce", "dam koman",
    #     "dam ta kom korun", "ektu kom korun", "dam onek beshi", "kom daben", "discount diben", "beshi dam",
    #     "ржжрж╛ржо ржХржорж╛ржирзЛ", "ржПржХржЯрзБ ржХржорж╛ржирзЛ", "ржжрж╛ржоржЯрж╛ ржЕржирзЗржХ", "ржПржд ржжрж╛ржо ржХрзЗржирзЛ", "ржХржорж╛ржирзЛ ржпрж╛ржпрж╝ ржХрж┐ржирж╛", "ржХржорж╛ржирзЛ ржпрж╛ржпрж╝ ржирж╛",
    #     "ржжрж╛ржо ржХржоржмрзЗ", "ржХржо ржХрж░рзЗржи", "ржХржо ржХрж░рзЗ ржжрзЗржи", "ржжрж╛ржо ржЕржирзЗржХ ржмрзЗрж╢рж┐", "ржЕржирзЗржХ ржжрж╛ржорж┐", "ржХржд ржбрж┐рж╕ржХрж╛ржЙржирзНржЯ",
    #     "ржбрж┐рж╕ржХрж╛ржЙржирзНржЯ ржкрж╛ржмрзЛ", "рж╕рзЗрж░рж╛ ржжрж╛ржо", "ржЕржлрж╛рж░ ржЖржЫрзЗ", "ржХржо ржХрж░рзБржи", "ржжрж╛ржо ржмрзЗрж╢рж┐", "ржХржо ржжрж╛ржорзЗ", "ржбрж┐рж╕ржХрж╛ржЙржирзНржЯ ржжрж┐ржи",
    #     "ржжрж╛ржо ржХржорж╛ржи", "ржжрж╛ржоржЯрж╛ ржХржо ржХрж░рзБржи", "ржПржХржЯрзБ ржХржо ржХрж░рзБржи", "ржжрж╛ржо ржЕржирзЗржХ ржмрзЗрж╢рж┐", "ржХржо ржжрж╛ржмрзЗржи", "ржбрж┐рж╕ржХрж╛ржЙржирзНржЯ ржжрж┐ржмрзЗржи",
    #     "ржмрзЗрж╢рж┐ ржжрж╛ржо"
    # ]

    # if any(k in user_query.lower() for k in bargaining_keywords):
    #   bot_response = validate_offer_price(bot_response, retrieved_products)

    # Increment message count
    try:
        with db_service.get_cursor() as (cursor, connection):
            cursor.execute("UPDATE business_settings SET value = value + 1 WHERE `key` = 'number_of_message'")
            connection.commit()
    except Exception as e:
        print(f"Error incrementing message count: {e}")

    # Save to memory
    memory.save_context({"user_query": user_query}, {"output": bot_response})

    return JSONResponse(content={
        "reply": bot_response,
        "related_products": [{k: v for k, v in product.items() if k != "marginal_price"} for product in retrieved_products],
        "session_id": session_id
    })

def send_to_facebook(recipient_id: str, message_text: str = None, image_url: str = None):
    """Send message or image back to user via Facebook Graph API."""
    if image_url:
        payload = {
            "messaging_type": "RESPONSE",
            "recipient": {"id": recipient_id},
            "message": {
                "attachment": {
                    "type": "image",
                    "payload": {
                        "url": image_url,
                        "is_reusable": True
                    }
                }
            }
        }
    else:
        payload = {
            "messaging_type": "RESPONSE",
            "recipient": {"id": recipient_id},
            "message": {"text": message_text}
        }
    
    response = requests.post(
        settings.FB_GRAPH_URL,
        json=payload,
        headers={"Content-Type": "application/json"}
    )
    if response.status_code != 200:
        print(f"Error sending message: {response.text}")
    return response.status_code == 200

@router.get("/webhook")
async def verify_webhook(request: Request):
    mode = request.query_params.get("hub.mode")
    token = request.query_params.get("hub.verify_token")
    challenge = request.query_params.get("hub.challenge")
    
    print(f"VERIFY_TOKEN: {settings.VERIFY_TOKEN}, Received token: {token}")
    if mode == "subscribe" and token == settings.VERIFY_TOKEN:
        return Response(content=str(challenge), status_code=200)
    else:
        raise HTTPException(status_code=403, detail="Forbidden")

@router.post("/webhook")
async def receive_webhook(request: Request):
    data = await request.json()
    if data.get("object") != "page":
        return JSONResponse(status_code=200, content={"status": "ok"})

    for entry in data.get("entry", []):
        messaging = entry.get("messaging", [])
        for message_data in messaging:
            sender_id = message_data["sender"]["id"]
            print("Received message_data:", message_data)
            incoming_msg = message_data["message"].get("text", "")
            files = []

            # Handle multiple image attachments
            attachments = message_data["message"].get("attachments", [])
            if attachments:
                for idx, attachment in enumerate(attachments):
                    if attachment["type"] == "image":
                        image_url = attachment["payload"]["url"]
                        async with httpx.AsyncClient() as client:
                            image_response = await client.get(image_url)
                            if image_response.status_code == 200:
                                image_content = image_response.content
                                files.append(
                                    (
                                        "images",  # must match parameter name in /api/chat
                                        (f"image_{sender_id}_{idx}.jpg", image_content, "image/jpeg")
                                    )
                                )
                            else:
                                print(f"Failed to download image: {image_response.status_code}")
            
            if not incoming_msg and not files:
                send_to_facebook(sender_id, "Please send a text message or an image to search for products.")
                continue

            session_id = sender_id
            async with httpx.AsyncClient() as client:
                print("Sending to /chat:", {"text": incoming_msg, "session_id": session_id, "files_count": len(files)})
                if files:
                    response = await client.post(
                        "https://chat.momsandkidsworld.com/api/chat",
                        data={"text": incoming_msg, "session_id": session_id},
                        files=files,  # тЬЕ Now can send multiple images
                        timeout=30.0
                    )
                else:
                    response = await client.post(
                        "https://chat.momsandkidsworld.com/api/chat",
                        data={"text": incoming_msg, "session_id": session_id},
                        timeout=30.0
                    )

                if response.status_code != 200:
                    print(f"Error from /chat: {response.status_code}, {response.text}")
                    bot_reply = "Sorry, something went wrong."
                else:
                    result = response.json()
                    bot_reply = result["reply"]

            send_to_facebook(sender_id, bot_reply)

    return JSONResponse(status_code=200, content={"status": "ok"})