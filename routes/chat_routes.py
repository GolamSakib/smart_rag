from fastapi import APIRouter, File, UploadFile, Form, HTTPException, Request, Response
from fastapi.responses import JSONResponse
from PIL import Image
from typing import List, Optional
from langchain.memory import ConversationBufferMemory
from langchain.prompts import PromptTemplate
from langchain_core.runnables import RunnableSequence
from uuid import uuid4
from collections import defaultdict
import numpy as np
import httpx
import requests
import re
import gspread
from google.oauth2.service_account import Credentials
from datetime import datetime,timedelta  
from services.model_manager import model_manager
from config.settings import settings
from services.database_service import db_service






# Keep a small in-memory cache to avoid duplicate processing
processed_messages = set()

router = APIRouter()


# In-memory store for per-session memory
session_memories = defaultdict(lambda: {
    "memory": ConversationBufferMemory(memory_key="chat_history", return_messages=True),
    "last_products": [],  # Store last retrieved products
    "message_count": 0    # Track number of messages in the session
})

# Updated Prompt template with discount calculation rule
from langchain.prompts import PromptTemplate

prompt = PromptTemplate(
    input_variables=["chat_history", "user_query", "context"],
    template=(
        "ржЖрж╕рж╕рж╛рж▓рж╛ржорзБ ржЖрж▓рж╛ржЗржХрзБржо! ржЖржкржирж┐ momsandkidsworld ржПрж░ ржПржХржЬржи ржмржирзНржзрзБрждрзНржмржкрзВрж░рзНржг, рж╕рзБржкрж╛рж░ рж╕рзНржЯрж╛ржЗрж▓рж┐рж╢ ржПржмржВ ржкрзЗрж╢рж╛ржжрж╛рж░ ржмрж┐ржХрзНрж░ржпрж╝ рж╕рж╣ржХрж╛рж░рзАред ржЖржорж░рж╛ ржмрзНржпрж╛ржЧ ржУ ржЬрзБрждрж╛ржпрж╝ рж░ржВ ржЫржбрж╝рж╛ржЗ! ржкрзНрж░ржержо ржмрж╛рж░рзНрждрж╛ржпрж╝ ржЗрж╕рж▓рж╛ржорж┐ржХ ржЕржнрж┐ржмрж╛ржжржи 'ржЖрж╕рж╕рж╛рж▓рж╛ржорзБ ржЖрж▓рж╛ржЗржХрзБржо' ржмрзНржпржмрж╣рж╛рж░ ржХрж░рзБржи, ржкрж░ржмрж░рзНрждрзАрждрзЗ рж╢рзБржзрзБ ржмрзНржпржмрж╣рж╛рж░ржХрж╛рж░рзАрж░ ржЕржирзБрж░рзЛржзрзЗред ржЙрждрзНрждрж░ ржмрж╛ржВрж▓рж╛ржпрж╝, рж╕ржВржХрзНрж╖рж┐ржкрзНржд, ржоржЬрж╛ржжрж╛рж░ ржПржмржВ ржЙрзОрж╕рж╛рж╣рзА ржЯрзЛржирзЗ ржжрж┐ржитАФржХрзНрж░ржпрж╝рзЗ ржЖржЧрзНрж░рж╣ ржЬрж╛ржЧрж╛рждрзЗ! 'ржкрзНрж░рж┐ржпрж╝ ржЧрзНрж░рж╛рж╣ржХ', 'ржзржирзНржпржмрж╛ржж', 'ржЖржкржирж╛рж░ рж╕рзНржЯрж╛ржЗрж▓рзЗрж░ ржЬржирзНржп' ржмрзНржпржмрж╣рж╛рж░ ржХрж░рзЗ рж╕ржорзНржорж╛ржи ржжрзЗржЦрж╛ржиред ржЧрзНрж░рж╛рж╣ржХрзЗрж░ ржЪрж╛рж╣рж┐ржжрж╛ ржмрзБржЭрзЗ рж╕рж╛ржЬрзЗрж╢ржи ржжрж┐ржи, рж╕рзБржмрж┐ржзрж╛ рждрзБрж▓рзЗ ржзрж░рзБржи, ржЖрж╕рзНржерж╛ рждрзИрж░рж┐ ржХрж░рзБржи, рж╣рж╛рж▓ржХрж╛ рж╣рж╛рж╕рзНржпрж░рж╕ ржпрзЛржЧ ржХрж░рзЗ ржХрзНрж░ржпрж╝рзЗрж░ ржжрж┐ржХрзЗ ржирж┐ржпрж╝рзЗ ржпрж╛ржитАФржЬрзЛрж░ ржХрж░рзЗ ржиржпрж╝ред\n"
        
        "ржпржжрж┐ ржмрзНржпржмрж╣рж╛рж░ржХрж╛рж░рзА ржЬрж┐ржЬрзНржЮрж╛рж╕рж╛ ржХрж░рзЗржи ржЖржкржирж┐ AI ржХрж┐ржирж╛, ржмрж▓рзБржи: 'ржЖржорж┐ momsandkidsworld ржПрж░ рж╕рзБржкрж╛рж░ ржлрзНрж░рзЗржирзНржбрж▓рж┐ ржмрж┐ржХрзНрж░ржпрж╝ рж╕рж╣ржХрж╛рж░рзА, ржЖржкржирж╛рж░ рж╕рзНржЯрж╛ржЗрж▓ ржЬрж╛рж░рзНржирж┐рж░ рж╕ржЩрзНржЧрзА!' \n"
        "ржЙрждрзНрждрж░ рзорзж рж╢ржмрзНржжрзЗрж░ ржоржзрзНржпрзЗ рж░рж╛ржЦрзБржи, ржоржЬрж╛рж░ ржЯрзЛржи ржмржЬрж╛ржпрж╝ рж░рзЗржЦрзЗред\n"
        "ржЕржкрзНрж░ржпрж╝рзЛржЬржирзАржпрж╝ ржнрзВржорж┐ржХрж╛ ржмрж╛ ржЙржкрж╕ржВрж╣рж╛рж░ ржПржбрж╝рж╛ржиред\n"
        "ржХржиржЯрзЗржХрзНрж╕ржЯрзЗрж░ ржкржгрзНржпрзЗрж░ ржмрж┐ржмрж░ржг (ржирж╛ржо, ржорзВрж▓рзНржп, рж▓рж┐ржЩрзНржХ) ржЕржкрж░рж┐ржмрж░рзНрждрж┐ржд рж░рж╛ржЦрзБржиред ржПржХржЯрж┐ ржкржгрзНржп рж╣рж▓рзЗ рж╕ржВржЦрзНржпрж╛ ржмрзНржпржмрж╣рж╛рж░ ржХрж░ржмрзЗржи ржирж╛, ржПржХрж╛ржзрж┐ржХ рж╣рж▓рзЗ ржмрж╛ржВрж▓рж╛ рж╕ржВржЦрзНржпрж╛ (рзз, рзи, рзй) ржмрзНржпржмрж╣рж╛рж░ ржХрж░рзБржиред\n"
        "ржмрзНржпржмрж╣рж╛рж░ржХрж╛рж░рзА 'link', 'website' ржмрж▓рж▓рзЗ ржмрж▓рзБржи: 'ржЖржкржирж╛рж░ рж╕рзНржЯрж╛ржЗрж▓ ржжрзЗржЦрждрзЗ ржЖржорж╛ржжрзЗрж░ ржУржпрж╝рзЗржмрж╕рж╛ржЗржЯрзЗ ржЪрзЛржЦ ржмрзБрж▓рж╛ржи!' ржПржмржВ рж▓рж┐ржЩрзНржХ ржжрж┐ржиред\n"
        "ржЬрзБрждрж╛ ржмрж╛ рж╕рж╛ржЗржЬ-рж╕ржорзНржкрж░рзНржХрж┐ржд ржкржгрзНржп рж╣рж▓рзЗ ржмрж┐ржмрж░ржг рж╕рзНржмржпрж╝ржВржХрзНрж░рж┐ржпрж╝ржнрж╛ржмрзЗ ржжрж┐ржиред ржЕржирзНржпржерж╛ржпрж╝, 'description', 'ржмрж░рзНржгржирж╛', 'details' ржЪрж╛ржЗрж▓рзЗ ржмрж┐ржмрж░ржг ржжрж┐ржи ржПржмржВ ржпрзЛржЧ ржХрж░рзБржи: 'ржЖржорж╛ржжрзЗрж░ ржкрзНрж░рзЛржбрж╛ржХрзНржЯ ржЪрж╛рзЯржирж╛ ржУ ржерж╛ржЗрж▓рзНржпрж╛ржирзНржб ржерзЗржХрзЗ ржЗржоржкрзЛрж░рзНржЯтАФржХрзЛрзЯрж╛рж▓рж┐ржЯрж┐ ржЯржк-ржиржЪ! ржЖржЧрзЗ ржкржгрзНржп, ржкрж░рзЗ ржЯрж╛ржХрж╛тАФрззрзжрзж% ржирж┐рж░рж╛ржкржж ржХрзЗржирж╛ржХрж╛ржЯрж╛ред рж░рж┐ржЯрж╛рж░рзНржи ржЕржкрж╢ржиржУ ржЖржЫрзЗ, рж╕рзНржЯрж╛ржЗрж▓ ржирж┐ржпрж╝рзЗ ржЭрзБржБржХрж┐ ржирзЗржЗ!' \n"
        "ржЫржмрж┐ ржЖржкрж▓рзЛржб ржХрж░рж▓рзЗ рж╢рзБржзрзБ ржорзВрж▓рзНржп ржжрж┐ржи, ржмрж┐ржмрж░ржг ржЪрж╛ржЗрж▓рзЗ ржжрж┐ржиред\n"
        
        "ржЫржмрж┐ ржжрзЗржЦрждрзЗ ржЪрж╛ржЗрж▓рзЗ ржмрж▓рзБржи: 'ржкрзНрж░рж┐ржпрж╝ ржЧрзНрж░рж╛рж╣ржХ, ржПржХржЯрзБ ржЕржкрзЗржХрзНрж╖рж╛ ржХрж░рзБржи, ржЖржорж╛ржжрзЗрж░ ржоржбрж╛рж░рзЗржЯрж░ ржПрж╕рзЗ ржЖржкржирж╛рж░ ржЬржирзНржп рж╕рзНржЯрж╛ржЗрж▓рж┐рж╢ ржЫржмрж┐ ржжрзЗржЦрж╛ржмрзЗржи!' \n"
        "'pp', 'price' ржЬрж┐ржЬрзНржЮрж╛рж╕рж╛ ржХрж░рж▓рзЗ ржХржиржЯрзЗржХрзНрж╕ржЯ ржерзЗржХрзЗ ржкрзНрж░рж╛рж╕ржЩрзНржЧрж┐ржХ ржкржгрзНржпрзЗрж░ ржорзВрж▓рзНржп ржжрж┐ржиред\n"
        "'рж╣рзБржмрж╣рзБ ржЫржмрж┐рж░ ржорждрзЛ' ржЬрж┐ржЬрзНржЮрж╛рж╕рж╛ ржХрж░рж▓рзЗ ржмрж▓рзБржи: 'ржПржХржжржо ржЫржмрж┐рж░ ржХржкрж┐! ржЖржорж░рж╛ ржЧрзНржпрж╛рж░рж╛ржирзНржЯрж┐ ржжрж┐ржЪрзНржЫрж┐, ржЖржкржирж╛рж░ рж╕рзНржЯрж╛ржЗрж▓ рж╣ржмрзЗ рж╣рзБржмрж╣рзБ ржЫржмрж┐рж░ ржорждрзЛ!' \n"
        "ржЕрж░рзНржбрж╛рж░ ржХрж░рждрзЗ ржЪрж╛ржЗрж▓рзЗ (ржЬрзБрждрж╛рж░ рж╕рж╛ржЗржЬ ржерж╛ржХрж▓рзЗ): 'ржЖржкржирж╛рж░ ржкрж╛ржпрж╝рзЗрж░ рж╕рзНржЯрж╛ржЗрж▓ ржХрзЛржи рж╕рж╛ржЗржЬрзЗ ржлрж┐ржЯ? ржжржпрж╝рж╛ ржХрж░рзЗ рж╕рж╛ржЗржЬ ржЬрж╛ржирж╛ржиред' ржЕржирзНржпржерж╛ржпрж╝: 'ЁЯУж ржЕрж░рзНржбрж╛рж░ рж▓ржХ ржХрж░рждрзЗ ржжрж┐ржи:\nЁЯПа ржПрж▓рж╛ржХрж╛ (ржпрзЗржоржитАУржЪрж╛рж╖рж╛ржбрж╝рж╛, ржзрж╛ржиржоржирзНржбрж┐)\nЁЯУ▒ ржорзЛржмрж╛ржЗрж▓ ржирж╛ржорзНржмрж╛рж░\nЁЯТ░ ржкржгрзНржп рж╣рж╛рждрзЗ ржкрзЗржпрж╝рзЗ ржЪрзЗржХ ржХрж░рзЗ ржХрзНржпрж╛рж╢ ржжрж┐ржитАФржЭрж╛ржорзЗрж▓рж╛ ржлрзНрж░рж┐!' \n"
        "ржЕрж░рзНржбрж╛рж░ ржХржиржлрж╛рж░рзНржо рж╣рж▓рзЗ ржкрзНрж░ржорзЛржЯ ржХрж░ржмрзЗржи ржирж╛ред ржзржирзНржпржмрж╛ржж ржжрж┐ржпрж╝рзЗ рж╢рзЗрж╖ ржХрж░рзБржиред\n"
        
        "ржХрзЛржпрж╝рж╛рж▓рж┐ржЯрж┐ ржирж┐ржпрж╝рзЗ ржкрзНрж░рж╢рзНржи рж╣рж▓рзЗ: 'ржбрзЗрж▓рж┐ржнрж╛рж░рж┐ ржорзНржпрж╛ржирзЗрж░ рж╕рж╛ржоржирзЗ ржкрзНрж░рзЛржбрж╛ржХрзНржЯ ржЪрзЗржХ ржХрж░рзБржиред ржкржЫржирзНржж ржирж╛ рж╣рж▓рзЗ рж╢рзБржзрзБ ржбрзЗрж▓рж┐ржнрж╛рж░рж┐ ржЪрж╛рж░рзНржЬ ржжрж┐ржпрж╝рзЗ рж░рж┐ржЯрж╛рж░рзНржи ржХрж░рзБржиред ржбрзНржпрж╛ржорзЗржЬ ржмрж╛ ржнрзБрж▓ ржкржгрзНржп рж╣рж▓рзЗ ржЪрж╛рж░рзНржЬ ржлрзНрж░рж┐ рж░рж┐ржЯрж╛рж░рзНржи! ржбрзЗрж▓рж┐ржнрж╛рж░рж┐ ржорзНржпрж╛ржи ржЪрж▓рзЗ ржЧрзЗрж▓рзЗ рж░рж┐ржЯрж╛рж░рзНржи ржЧрзНрж░рж╣ржг рж╣ржмрзЗ ржирж╛ред' \n"
        "ржЕрж░рзНржбрж╛рж░ ржЯрзНрж░рзНржпрж╛ржХрж┐ржВ ржЬрж┐ржЬрзНржЮрж╛рж╕рж╛ ржХрж░рж▓рзЗ: 'ржкрзНрж░рж┐ржпрж╝ ржЧрзНрж░рж╛рж╣ржХ, ржПржХржЯрзБ ржзрзИрж░рзНржп ржзрж░рзБржи! ржЖржорж╛ржжрзЗрж░ ржоржбрж╛рж░рзЗржЯрж░ рж╕рзБржкрж╛рж░ ржлрж╛рж╕рзНржЯ ржЖржкржирж╛рж░ ржЕрж░рзНржбрж╛рж░рзЗрж░ ржЦржмрж░ ржжрзЗржмрзЗред ржХрзБрж░рж┐ржпрж╝рж╛рж░ ржЯрж┐ржо ржорзЗрж╕рзЗржЬ ржХрж░ржмрзЗ, ржЕржкрзЗржХрзНрж╖рж╛ ржХрж░рзБржи ЁЯТЪ' \n"
        "ржЕржнрж┐ржпрзЛржЧ рж╣рж▓рзЗ: 'ржкрзНрж░рж┐ржпрж╝ ржЧрзНрж░рж╛рж╣ржХ, ржЯрзЗржирж╢ржи ржирзЗржЗ! ржЖржорж╛ржжрзЗрж░ тАЬProblem ResolveтАЭ ржЯрж┐ржо ржжрзНрж░рзБржд ржЖржкржирж╛рж░ рж╕рж╛ржерзЗ ржпрзЛржЧрж╛ржпрзЛржЧ ржХрж░ржмрзЗред ржПржХржЯрзБ ржЕржкрзЗржХрзНрж╖рж╛ ржХрж░рзБржи, рж╕ржорж╛ржзрж╛ржи ржкрж╛ржмрзЗржи ЁЯТЪ' \n"
        
        "ржжрж░ржжрж╛ржо ржХрж░рж▓рзЗ ржоржЬрж╛рж░ ржЯрзЛржирзЗ ржЙрждрзНрждрж░ ржжрж┐ржи: 'ржжрж╛ржоржЯрж╛ ржЖржорж╛ржжрзЗрж░ рж╣рзГржжржпрж╝рзЗрж░ ржорждрзЛтАФржПржХржжржо ржлрж┐ржХрзНрж╕ржб! ржХрж┐ржирзНрждрзБ ржЧрзБржгржорж╛ржи ржПржоржи ржпрзЗ ржЖржкржирж┐ ржмрж┐рж╢рзНржмрж╛рж╕ ржЗ ржХрж░ржмрзЗржи ржирж╛ред ржПржЦржиржЗ ржЕрж░рзНржбрж╛рж░ ржХрж░рж▓рзЗ ржкрзНрж░рзЛржбрж╛ржХрзНржЯ рждрж╛ржбрж╝рж╛рждрж╛ржбрж╝рж┐ ржкрзМржБржЫрж╛ржмрзЗ!' (ржЪрзНржпрж╛ржЯ рж╣рж┐рж╕рзНржЯрзНрж░рж┐ ржЕржирзБржпрж╛ржпрж╝рзА ржнрзНржпрж╛рж░рж┐ржпрж╝рзЗрж╢ржи ржЖржирзБржитАФржкрзНрж░ржержоржмрж╛рж░ рж╕рж░рж╛рж╕рж░рж┐, ржжрзНржмрж┐рждрзАржпрж╝ржмрж╛рж░ ржоржЬрж╛рж░ ржЯрзБржЗрж╕рзНржЯ, рждрзГрждрзАржпрж╝ржмрж╛рж░ рж╕ржорзНржкрж░рзНржХ ржЧрж╛ржврж╝ ржХрж░рзЗред) \n"
        
        "ржбрзЗрж▓рж┐ржнрж╛рж░рж┐ ржЬрж┐ржЬрзНржЮрж╛рж╕рж╛ ржХрж░рж▓рзЗ: 'ЁЯЪЪ рж╕рж╛рж░рж╛ ржмрж╛ржВрж▓рж╛ржжрзЗрж╢рзЗ ржХрзНржпрж╛рж╢ ржЕржи ржбрзЗрж▓рж┐ржнрж╛рж░рж┐! ржкрж╛ржарж╛ржУ ржХрзБрж░рж┐ржпрж╝рж╛рж░рзЗ ржЭржЯржкржЯ ржкрзМржБржЫрзЗ ржпрж╛ржмрзЗред ржврж╛ржХрж╛ржпрж╝ рзз ржжрж┐ржи, ржХрж╛ржЫрж╛ржХрж╛ржЫрж┐ ржПрж▓рж╛ржХрж╛ржпрж╝(ржпрзЗржоржитАУ ржХрзЗрж░рж╛ржирзАржЧржЮрзНржЬ, ржирж╛рж░рж╛рзЯржгржЧржЮрзНржЬ, рж╕рж╛ржнрж╛рж░, ржЧрж╛ржЬрзАржкрзБрж░) рзз-рзи ржжрж┐ржи, ржмрж╛ржЗрж░рзЗ рзи-рзй ржжрж┐ржирзЗ ржЗржирж╢рж╛ржЖрж▓рзНрж▓рж╛рж╣ред ржЪрж╛рж░рзНржЬ: ржврж╛ржХрж╛ржпрж╝ рзорзж ржЯрж╛ржХрж╛, рж╕рж╛ржм-ржПрж▓рж╛ржХрж╛ржпрж╝(ржирж╛рж░рж╛ржпрж╝ржгржЧржЮрзНржЬ, ржЧрж╛ржЬрзАржкрзБрж░, рж╕рж╛ржнрж╛рж░, ржХрзЗрж░рж╛ржирзАржЧржЮрзНржЬ) рззрзйрзж ржЯрж╛ржХрж╛, ржмрж╛ржЗрж░рзЗ рззрзлрзж ржЯрж╛ржХрж╛ред ржкржгрзНржп рж╣рж╛рждрзЗ ржкрзЗржпрж╝рзЗ ржЯрж╛ржХрж╛ ржжрж┐ржитАФржЭржХрзНржХрж┐ ржирзЗржЗ!' \n"
        
        "рж░рж┐ржЯрж╛рж░рзНржи ржкрж▓рж┐рж╕рж┐ ржЬрж┐ржЬрзНржЮрж╛рж╕рж╛ ржХрж░рж▓рзЗ: 'ржбрзЗрж▓рж┐ржнрж╛рж░рж┐ ржорзНржпрж╛ржирзЗрж░ рж╕рж╛ржоржирзЗ ржкрзНрж░рзЛржбрж╛ржХрзНржЯ ржЪрзЗржХ ржХрж░рзБржиред ржкржЫржирзНржж ржирж╛ рж╣рж▓рзЗ рж╢рзБржзрзБ ржбрзЗрж▓рж┐ржнрж╛рж░рж┐ ржЪрж╛рж░рзНржЬ ржжрж┐ржпрж╝рзЗ рж░рж┐ржЯрж╛рж░рзНржиред ржбрзНржпрж╛ржорзЗржЬ ржмрж╛ ржнрзБрж▓ ржкржгрзНржп рж╣рж▓рзЗ ржлрзНрж░рж┐ рж░рж┐ржЯрж╛рж░рзНржи! ржбрзЗрж▓рж┐ржнрж╛рж░рж┐ ржорзНржпрж╛ржи ржЪрж▓рзЗ ржЧрзЗрж▓рзЗ рж░рж┐ржЯрж╛рж░рзНржи ржирзЗржУржпрж╝рж╛ ржпрж╛ржмрзЗ ржирж╛ред' \n"
        
        "ржЬрзБрждрж╛рж░ рж╕рж╛ржЗржЬ ржЪрж╛рж░рзНржЯ ржЬрж┐ржЬрзНржЮрж╛рж╕рж╛ ржХрж░рж▓рзЗ: 'ржЖржорж╛ржжрзЗрж░ ржЬрзБрждрж╛рж░ рж╕рж╛ржЗржЬ ржЪрж╛рж░рзНржЯ рж╕рзБржкрж╛рж░ рж╕рж┐ржорзНржкрж▓! Bata/Apex ржЬрзБрждрж╛рж░ ржирж┐ржЪрзЗ рж╕рж╛ржЗржЬ ржжрзЗржЦрзБржиред рзйрзл=рзирзз.рзм рж╕рзЗржорж┐, рзйрзм=рзирзи.рзл рж╕рзЗржорж┐, рзйрзн=рзирзй.рзл рж╕рзЗржорж┐, рзйрзо=рзирзк рж╕рзЗржорж┐, рзйрзп=рзирзл рж╕рзЗржорж┐, рзкрзж=рзирзл.рзп рж╕рзЗржорж┐, рзкрзз=рзирзм.рзк рж╕рзЗржорж┐, рзкрзи=рзирзм.рзо рж╕рзЗржорж┐ред ржЖржкржирж╛рж░ Bata/Apex рж╕рж╛ржЗржЬ ржмрж▓рзБржи, ржкрж╛рж░ржлрзЗржХрзНржЯ ржЬрзБрждрж╛ ржкрж╛ржарж╛ржмрзЛ!' \n"
        
        "ржбрзЗрж▓рж┐ржнрж╛рж░рж┐ ржЪрж╛рж░рзНржЬрж╕рж╣ ржорзЛржЯ ржорзВрж▓рзНржп ржЬрж┐ржЬрзНржЮрж╛рж╕рж╛ ржХрж░рж▓рзЗ: 'ржкржгрзНржпрзЗрж░ ржжрж╛ржо [product price] ржЯрж╛ржХрж╛, ржбрзЗрж▓рж┐ржнрж╛рж░рж┐ ржЪрж╛рж░рзНржЬ [80/130/150] ржЯрж╛ржХрж╛ рж╕рж╣ ржорзЛржЯ [total price] ржЯрж╛ржХрж╛ред ржПржЦржиржЗ ржЕрж░рзНржбрж╛рж░ ржХрж░рзБржи, рж╕рзНржЯрж╛ржЗрж▓ рж╣рж╛рждрзЗ ржкрзМржБржЫрзЗ ржпрж╛ржмрзЗ!' \n"
        
        "ржХржиржЯрзЗржХрзНрж╕ржЯ:\n{context}\n\n"
        "ржЪрзНржпрж╛ржЯ рж╣рж┐рж╕рзНржЯрзНрж░рж┐:\n{chat_history}\n\n"
        "ржмрзНржпржмрж╣рж╛рж░ржХрж╛рж░рзА: {user_query}\nржмржЯ: "
    )
)


def validate_offer_price(response: str, products: List[dict]) -> str:
    """
    Validate the offered price in the bot's response to ensure it is not below the marginal price.
    If below, adjust to the marginal price of the most relevant product.
    """
    if not products:
        return response
    
    # Assume the first product is the most relevant
    marginal_price = float(products[0]["marginal_price"])
    print(f"Marginal price of the most relevant product: {marginal_price}")
    
    # Extract the offered price from the response (assuming format like "[number] ржЯрж╛ржХрж╛")
    match = re.search(r'(\d+\.?\d*)\s*ржЯрж╛ржХрж╛', response)
    if match:
        offered_price = float(match.group(1))
        if offered_price < marginal_price:
            # Replace the offered price with the marginal price
            response = re.sub(r'\d+\.?\d*\s*ржЯрж╛ржХрж╛', f"{int(marginal_price)} ржЯрж╛ржХрж╛", response)
    
    return response

def add_to_google_sheet(phone_number: str):
    try:
        scope = ["https://spreadsheets.google.com/feeds", "https://www.googleapis.com/auth/drive"]
        creds = Credentials.from_service_account_file("google_sheet.json", scopes=scope)
        client = gspread.authorize(creds)
        sheet = client.open_by_key("1eEuya073QSg0iXsued7e1xJbcrRdKuD7UH7JsyQLvS0").sheet1
        
        today_date = datetime.now().strftime("%Y-%m-%d")
        sheet.insert_row([phone_number, today_date], index=2) # index=2 to insert at the top after header
        print(f"Successfully added {phone_number} to Google Sheet.")
    except Exception as e:
        print(f"Error adding to Google Sheet: {e}")

@router.post("/api/chat")
async def chat(
    images: Optional[List[UploadFile]] = File(None),
    text: Optional[str] = Form(None),
    session_id: Optional[str] = Form(None)
):  
    # bot_response = "Hello"
    # return JSONResponse(content={
    #     "reply": bot_response,
    #     "related_products": [],
    #     "session_id": session_id
    # })
    if not images and not text:
        return JSONResponse(status_code=400, content={"error": "At least one image or text input is required"})
    


    
    session_id = session_id or str(uuid4())
    session_data = session_memories[session_id]
    memory = session_data["memory"]
    retrieved_products = session_data["last_products"]
    session_data["message_count"] += 1  # Increment message count

    # Define query early to allow conditional logic
    user_query = text.strip() if text else "ржЖржкрж▓рзЛржб ржХрж░рж╛ ржкржгрзНржпржЧрзБрж▓рзЛрж░ ржирж╛ржо ржПржмржВ ржорзВрж▓рзНржп ржкрзНрж░ржжрж╛ржи ржХрж░рзБржиред"

    # Image search - Process images FIRST, before checking for greetings
    if images:
        retrieved_products = []
        image_index = model_manager.get_image_index()
        image_metadata = model_manager.get_image_metadata()
        
        if image_index is None or not image_metadata:
            return JSONResponse(status_code=500, content={"error": "Image search not available"})
            
        for image_file in images:
            image = Image.open(image_file.file)
            image_embedding = model_manager.get_image_embedding(image)
            D, I = image_index.search(np.array([image_embedding]).astype('float32'), k=1)
            retrieved_products.append(image_metadata[I[0][0]])
        session_data["last_products"] = retrieved_products

    print("retrieved_products:", retrieved_products)

    # Handle greeting/price query for first-time users with no product context
    # CHECK THIS AFTER image processing but BEFORE text search
    if not retrieved_products and any(k in user_query.lower() for k in ["pp", "price", "assalamu alaiikum", "salam", "ржЖрж╕рж╕рж╛рж▓рж╛ржорзБ ржЖрж▓рж╛ржЗржХрзБржо","ржкрзНрж░рж╛ржЗржЬ","ржкрзНрж░рж╛ржЗрж╕ ржХржд","ржжрж╛ржо", "ржорзВрж▓рзНржп", "hi", "hello", "hey", "рж╣рж╛ржЗ", "рж╣рзНржпрж╛рж▓рзЛ", "рж╣рзЗрж▓рзЛ", ".", "ЁЯШК", "ЁЯШВ", "тЭдя╕П", "ЁЯСН", "ЁЯЩП", "ЁЯдй", "ЁЯШБ", "ЁЯШЮ", "ЁЯФе", "тЬи", "ЁЯОЙ"]):
        bot_response = "ржЖрж╕рж╕рж╛рж▓рж╛ржорзБ ржЖрж▓рж╛ржЗржХрзБржо...\n\nржЖржкржирж┐ ржпрзЗ ржкрзНрж░рзЛржбрж╛ржХрзНржЯ ржЯрж┐ рж╕ржорзНржкрж░рзНржХрзЗ ржЬрж╛ржирждрзЗ ржЪрж╛ржЪрзНржЫрзЗржи, ржжрзЯрж╛ ржХрж░рзЗ ржЫржмрж┐ ржжрж┐ржиред"
        return JSONResponse(content={
            "reply": bot_response,
            "related_products": [],
            "session_id": session_id
        })

    # Text search - now this block runs ONLY if the greeting condition was NOT met, and if 'text' is provided
    if text:
        # text_vector_store = model_manager.get_text_vector_store()
        # if text_vector_store is None:
        #     return JSONResponse(status_code=500, content={"error": "Text search not available"})
            
        # docs = text_vector_store.similarity_search(text, k=1)
        # for doc in docs:
        #     retrieved_products.append(doc.metadata)
        session_data["last_products"] = retrieved_products

    # Remove duplicates
    seen_products = set()
    unique_products = []
    for product in retrieved_products:
        identifier = (product.get('name', '').strip(), product.get('code', '').strip())
        if identifier not in seen_products:
            seen_products.add(identifier)
            unique_products.append(product)
    retrieved_products = unique_products

    # Build context
    context = "\nAvailable products:\n"
    for product in retrieved_products:
        context += f"- Name: {product['name']}, Price: {product['price']},Description: {product['description']} Link: {product['link']}\n"
    print("Context for LLM:", context)

    # Check for phone number and save to Google Sheet
    phone_pattern = r'(?:\d{8,11}|[рзж-рзп]{8,11})'
    match = re.search(phone_pattern, user_query)
    if match:
        phone_number = match.group(0)
        add_to_google_sheet(phone_number)

    llm = model_manager.get_llm()
    chain = RunnableSequence(prompt | llm)
    chat_history = memory.load_memory_variables({})["chat_history"]
    inputs = {"chat_history": chat_history, "user_query": user_query, "context": context}
    print(inputs)
    response = chain.invoke(inputs)
    bot_response = response.content
    print("Raw bot response:", bot_response)

    # Increment message count in database
    try:
        with db_service.get_cursor() as (cursor, connection):
            cursor.execute("UPDATE business_settings SET value = value + 1 WHERE `key` = 'number_of_message'")
            connection.commit()
    except Exception as e:
        print(f"Error incrementing message count: {e}")

    # Save to memory
    memory.save_context({"user_query": user_query}, {"output": bot_response})

    # Check if message count has reached 3 and clear memory if so
    if session_data["message_count"] >= 30:
        session_memories[session_id] = {
            "memory": ConversationBufferMemory(memory_key="chat_history", return_messages=True),
            "last_products": [],
            "message_count": 0
        }
        print(f"Session memory cleared for session_id: {session_id} after 15 messages")

    return JSONResponse(content={
        "reply": bot_response,
        "related_products": [{k: v for k, v in product.items() if k != "marginal_price"} for product in retrieved_products],
        "session_id": session_id
    })

def send_to_facebook(recipient_id: str, message_text: str = None, image_url: str = None):
    """Send message or image back to user via Facebook Graph API."""
    if image_url:
        payload = {
            "messaging_type": "RESPONSE",
            "recipient": {"id": recipient_id},
            "message": {
                "attachment": {
                    "type": "image",
                    "payload": {
                        "url": image_url,
                        "is_reusable": True
                    }
                }
            }
        }
    else:
        payload = {
            "messaging_type": "RESPONSE",
            "recipient": {"id": recipient_id},
            "message": {"text": message_text}
        }
    
    response = requests.post(
        settings.FB_GRAPH_URL,
        json=payload,
        headers={"Content-Type": "application/json"}
    )
    if response.status_code != 200:
        print(f"Error sending message: {response.text}")
    return response.status_code == 200

def mark_message_seen(recipient_id: str):
    """Tell Facebook that the bot's messages have been 'seen' by the user."""
    payload = {
        "recipient": {"id": recipient_id},
        "sender_action": "mark_seen"
    }
    response = requests.post(
        settings.FB_GRAPH_URL,
        json=payload,
        headers={"Content-Type": "application/json"}
    )
    if response.status_code != 200:
        print(f"Error marking message seen: {response.text}")
        



@router.get("/webhook")
async def verify_webhook(request: Request):
    mode = request.query_params.get("hub.mode")
    token = request.query_params.get("hub.verify_token")
    challenge = request.query_params.get("hub.challenge")
    
    print(f"VERIFY_TOKEN: {settings.VERIFY_TOKEN}, Received token: {token}")
    if mode == "subscribe" and token == settings.VERIFY_TOKEN:
        return Response(content=str(challenge), status_code=200)
    else:
        raise HTTPException(status_code=403, detail="Forbidden")

@router.post("/webhook")
async def receive_webhook(request: Request):
    data = await request.json()

    if data.get("object") != "page":
        return JSONResponse(status_code=200, content={"status": "ok"})

    for entry in data.get("entry", []):
        messaging = entry.get("messaging", [])
        for message_data in messaging:
            timestamp_ms = message_data.get("timestamp")
            if timestamp_ms:
                msg_time = datetime.fromtimestamp(timestamp_ms / 1000.0)
                if datetime.utcnow() - msg_time > timedelta(minutes=1):
                    print(f"тЪая╕П Ignoring old message from {msg_time}")
                    continue

            mid = message_data.get("message", {}).get("mid")
            if mid and mid in processed_messages:
                print(f"Duplicate message ignored: {mid}")
                continue
            if mid:
                processed_messages.add(mid)
    
                if len(processed_messages) > 100:
                    processed_messages.clear()
            sender_id = message_data["sender"]["id"]
            print("Received message_data:", message_data)
            incoming_msg = message_data["message"].get("text", "")
            files = []
            attachments = message_data["message"].get("attachments", [])
            if attachments:
                for idx, attachment in enumerate(attachments):
                    if attachment["type"] == "image":
                        image_url = attachment["payload"]["url"]
                        async with httpx.AsyncClient() as client:
                            image_response = await client.get(image_url)
                            if image_response.status_code == 200:
                                image_content = image_response.content
                                files.append(
                                    (
                                        "images",  
                                        (f"image_{sender_id}_{idx}.jpg", image_content, "image/jpeg")
                                    )
                                )
                            else:
                                print(f" Failed to download image: {image_response.status_code}")
            

            if not incoming_msg and not files:
                send_to_facebook(sender_id, "ржжрзЯрж╛ ржХрж░рзЗ рж▓рж┐ржЦрзЗ ржмрж▓рзБржи")
                continue

            session_id = sender_id
            async with httpx.AsyncClient() as client:
                print("Sending to /chat:", {"text": incoming_msg, "session_id": session_id, "files_count": len(files)})
                try:
                    if files:
                        response = await client.post(
                            "https://chat.momsandkidsworld.com/api/chat",
                            data={"text": incoming_msg, "session_id": session_id},
                            files=files,
                            timeout=30.0
                        )
                    else:
                        response = await client.post(
                            "https://chat.momsandkidsworld.com/api/chat",
                            data={"text": incoming_msg, "session_id": session_id},
                            timeout=30.0
                        )
                except httpx.RequestError as e:
                    print(f"Network error calling /chat: {e}")
                    send_to_facebook(sender_id, "Sorry, something went wrong while connecting to the chat server.")
                    continue
                if response.status_code != 200:
                    print(f"Error from /chat: {response.status_code}, {response.text}")
                    bot_reply = "Sorry, something went wrong."
                else:
                    result = response.json()
                    bot_reply = result.get("reply", "Sorry, I didnтАЩt understand that.")

            send_to_facebook(sender_id, bot_reply)
            mark_message_seen(sender_id)
            

    return JSONResponse(status_code=200, content={"status": "ok"})